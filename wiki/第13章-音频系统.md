# 第13章 音频系统

> **本章目标**：掌握 VoidKings 的音频管理机制，理解 BGM/音效分离、预加载、跨平台兼容等实现。

---

## 13.1 AudioManager 设计

### 13.1.1 BGM 与音效分离

VoidKings 使用命名空间封装音频功能：

```cpp
// Classes/Utils/AudioManager.h
#ifndef __AUDIO_MANAGER_H__
#define __AUDIO_MANAGER_H__

namespace AudioManager {
    // 初始化与预加载
    void preload();
    
    // 静音控制
    bool isBgmMuted();
    bool isSfxMuted();
    void setBgmMuted(bool muted);
    void setSfxMuted(bool muted);
    
    // 背景音乐
    void playMainBgm();
    void playBattleBgm(int levelId);
    void stopBgm();
    void pauseAll();
    void resumeAll();
    
    // 界面音效
    void playButtonClick();
    void playButtonCancel();
    
    // 战斗音效
    void playArrowShoot();
    void playArrowHit();
    void playMeleeHit();
    void playMagicAttack();
    void playMagicHit();
    void playBoom();
    void playSpikeAppear();
    void playSnapTrap();
    void playFireSpray();
    void playMoneyGet();
    void playBuildingCollapse();
    void playRandomHit();
    void playVictory();
    void playLose();
}

#endif
```

**为什么分离 BGM 和 SFX？**
- 用户可能只想关闭背景音乐
- 音量控制可以独立调节
- 技术上 BGM 需要流式播放，SFX 需要低延迟

### 13.1.2 静音状态管理

```cpp
// Classes/Utils/AudioManager.cpp
namespace {
    bool s_bgmMuted = false;
    bool s_sfxMuted = false;
    int s_currentBgmId = -1;
    
    // 音频文件路径
    const char* BGM_MAIN = "music/bgm_main.mp3";
    const char* BGM_BATTLE = "music/bgm_battle.mp3";
    
    const char* SFX_CLICK = "source/click.wav";
    const char* SFX_CANCEL = "source/cancel.wav";
    const char* SFX_ARROW_SHOOT = "source/arrow_shoot.wav";
    // ... 更多音效路径
}

namespace AudioManager {

bool isBgmMuted() {
    return s_bgmMuted;
}

bool isSfxMuted() {
    return s_sfxMuted;
}

void setBgmMuted(bool muted) {
    s_bgmMuted = muted;
    
    if (muted) {
        // 停止当前 BGM
        SimpleAudioEngine::getInstance()->stopBackgroundMusic();
    } else {
        // 恢复播放
        if (s_currentBgmId >= 0) {
            playBattleBgm(s_currentBgmId);
        } else {
            playMainBgm();
        }
    }
    
    // 保存设置
    UserDefault::getInstance()->setBoolForKey("bgm_muted", muted);
}

void setSfxMuted(bool muted) {
    s_sfxMuted = muted;
    UserDefault::getInstance()->setBoolForKey("sfx_muted", muted);
}

} // namespace AudioManager
```

### 13.1.3 预加载机制

```cpp
void AudioManager::preload() {
    auto audio = SimpleAudioEngine::getInstance();
    
    // 预加载背景音乐
    audio->preloadBackgroundMusic(BGM_MAIN);
    audio->preloadBackgroundMusic(BGM_BATTLE);
    
    // 预加载常用音效
    audio->preloadEffect(SFX_CLICK);
    audio->preloadEffect(SFX_CANCEL);
    audio->preloadEffect(SFX_ARROW_SHOOT);
    audio->preloadEffect(SFX_ARROW_HIT);
    audio->preloadEffect(SFX_MELEE_HIT);
    audio->preloadEffect(SFX_MAGIC_ATTACK);
    audio->preloadEffect(SFX_BOOM);
    // ... 更多音效
    
    // 加载静音设置
    s_bgmMuted = UserDefault::getInstance()->getBoolForKey("bgm_muted", false);
    s_sfxMuted = UserDefault::getInstance()->getBoolForKey("sfx_muted", false);
    
    CCLOG("[AudioManager] 音频预加载完成");
}
```

---

## 13.2 音频 API 封装

### 13.2.1 按钮音效

```cpp
void AudioManager::playButtonClick() {
    if (s_sfxMuted) return;
    SimpleAudioEngine::getInstance()->playEffect(SFX_CLICK);
}

void AudioManager::playButtonCancel() {
    if (s_sfxMuted) return;
    SimpleAudioEngine::getInstance()->playEffect(SFX_CANCEL);
}

// 使用示例
button->addClickEventListener([](Ref*) {
    AudioManager::playButtonClick();
    // 执行按钮逻辑
});
```

### 13.2.2 战斗音效

```cpp
void AudioManager::playArrowShoot() {
    if (s_sfxMuted) return;
    SimpleAudioEngine::getInstance()->playEffect(SFX_ARROW_SHOOT);
}

void AudioManager::playArrowHit() {
    if (s_sfxMuted) return;
    SimpleAudioEngine::getInstance()->playEffect(SFX_ARROW_HIT);
}

void AudioManager::playMeleeHit() {
    if (s_sfxMuted) return;
    SimpleAudioEngine::getInstance()->playEffect(SFX_MELEE_HIT);
}

void AudioManager::playBoom() {
    if (s_sfxMuted) return;
    SimpleAudioEngine::getInstance()->playEffect(SFX_BOOM, false, 1.0f, 0.0f, 1.2f);
    // 参数：循环、音调、声相、增益
}

void AudioManager::playRandomHit() {
    if (s_sfxMuted) return;
    
    // 随机选择一个命中音效
    int random = rand() % 3;
    switch (random) {
        case 0: playArrowHit(); break;
        case 1: playMeleeHit(); break;
        default: playMagicHit(); break;
    }
}

void AudioManager::playVictory() {
    if (s_sfxMuted) return;
    SimpleAudioEngine::getInstance()->playEffect("source/victory.wav");
}

void AudioManager::playLose() {
    if (s_sfxMuted) return;
    SimpleAudioEngine::getInstance()->playEffect("source/lose.wav");
}
```

### 13.2.3 背景音乐切换

```cpp
void AudioManager::playMainBgm() {
    if (s_bgmMuted) return;
    
    s_currentBgmId = -1;
    
    auto audio = SimpleAudioEngine::getInstance();
    audio->stopBackgroundMusic();
    audio->playBackgroundMusic(BGM_MAIN, true);  // true = 循环
}

void AudioManager::playBattleBgm(int levelId) {
    if (s_bgmMuted) return;
    
    s_currentBgmId = levelId;
    
    auto audio = SimpleAudioEngine::getInstance();
    audio->stopBackgroundMusic();
    
    // 可以根据关卡选择不同 BGM
    const char* bgmPath = BGM_BATTLE;
    if (levelId > 6) {
        bgmPath = "music/bgm_battle_hard.mp3";
    }
    
    audio->playBackgroundMusic(bgmPath, true);
}

void AudioManager::stopBgm() {
    SimpleAudioEngine::getInstance()->stopBackgroundMusic();
    s_currentBgmId = -1;
}

void AudioManager::pauseAll() {
    auto audio = SimpleAudioEngine::getInstance();
    audio->pauseBackgroundMusic();
    audio->pauseAllEffects();
}

void AudioManager::resumeAll() {
    if (s_bgmMuted && s_sfxMuted) return;
    
    auto audio = SimpleAudioEngine::getInstance();
    
    if (!s_bgmMuted) {
        audio->resumeBackgroundMusic();
    }
    if (!s_sfxMuted) {
        audio->resumeAllEffects();
    }
}
```

---

## 13.3 跨平台音频兼容

### 13.3.1 SimpleAudioEngine vs AudioEngine

Cocos2d-x 提供两套音频 API：

| 特性 | SimpleAudioEngine | AudioEngine |
|------|-------------------|-------------|
| 平台支持 | 全平台 | 全平台 |
| API 复杂度 | 简单 | 较复杂 |
| 功能 | 基础播放 | 高级控制 |
| 推荐场景 | 小型游戏 | 大型游戏 |

VoidKings 使用 `SimpleAudioEngine`：

```cpp
// SimpleAudioEngine 用法
#include "SimpleAudioEngine.h"
using namespace CocosDenshion;

auto audio = SimpleAudioEngine::getInstance();
audio->playBackgroundMusic("bgm.mp3", true);
audio->playEffect("sfx.wav");
audio->setBackgroundMusicVolume(0.8f);
audio->setEffectsVolume(1.0f);
```

如需更高级功能，可使用 `AudioEngine`：

```cpp
// AudioEngine 用法
#include "audio/include/AudioEngine.h"
using namespace cocos2d::experimental;

int bgmId = AudioEngine::play2d("bgm.mp3", true, 0.8f);
AudioEngine::setVolume(bgmId, 0.5f);
AudioEngine::pause(bgmId);
AudioEngine::resume(bgmId);
AudioEngine::stop(bgmId);
```

### 13.3.2 Android 音频路径处理

Android 上的资源路径自动映射到 `assets/` 目录：

```cpp
// 代码中的路径
"music/bgm_main.mp3"

// 实际对应 Android 项目中的
proj.android/app/assets/music/bgm_main.mp3
```

**常见问题与解决**：

```cpp
// 问题：音频文件找不到
// 原因：路径大小写不匹配（Android 区分大小写）

// 解决：统一使用小写文件名
"music/bgm_battle.mp3"  // ✓
"music/BGM_Battle.mp3"  // ❌ 可能找不到

// 问题：某些格式不支持
// 解决：使用通用格式
"music/bgm.mp3"   // ✓ MP3 通用
"music/bgm.ogg"   // ✓ OGG 推荐用于 Android
"music/bgm.wav"   // ✓ WAV（文件较大）
"music/bgm.mid"   // ❌ MIDI 支持有限
```

---

## 音量控制 UI

```cpp
// 设置界面示例
void SettingsPanel::createAudioControls() {
    // BGM 开关
    auto bgmToggle = CheckBox::create();
    bgmToggle->setSelected(!AudioManager::isBgmMuted());
    bgmToggle->addEventListener([](Ref*, CheckBox::EventType type) {
        bool selected = (type == CheckBox::EventType::SELECTED);
        AudioManager::setBgmMuted(!selected);
    });
    
    // SFX 开关
    auto sfxToggle = CheckBox::create();
    sfxToggle->setSelected(!AudioManager::isSfxMuted());
    sfxToggle->addEventListener([](Ref*, CheckBox::EventType type) {
        bool selected = (type == CheckBox::EventType::SELECTED);
        AudioManager::setSfxMuted(!selected);
    });
    
    // BGM 音量滑块
    auto bgmSlider = Slider::create();
    bgmSlider->setPercent(
        SimpleAudioEngine::getInstance()->getBackgroundMusicVolume() * 100);
    bgmSlider->addEventListener([](Ref*, Slider::EventType type) {
        if (type == Slider::EventType::ON_PERCENTAGE_CHANGED) {
            float vol = bgmSlider->getPercent() / 100.0f;
            SimpleAudioEngine::getInstance()->setBackgroundMusicVolume(vol);
        }
    });
}
```

---

## 音频事件时机

```cpp
// 正确的播放时机示例

// 1. 场景切换时
void MainMenuScene::onEnter() {
    Scene::onEnter();
    AudioManager::playMainBgm();
}

// 2. 按钮点击时
button->addClickEventListener([](Ref*) {
    AudioManager::playButtonClick();  // 先播放音效
    // ... 执行逻辑
});

// 3. 攻击命中时
void Soldier::performAttack() {
    if (_config->isRanged) {
        AudioManager::playArrowShoot();  // 发射时播放
    } else {
        AudioManager::playMeleeHit();    // 近战直接播放
    }
}

// 4. 战斗结束时
void BattleScene::onBattleEnd(bool win) {
    AudioManager::stopBgm();  // 先停止 BGM
    
    if (win) {
        AudioManager::playVictory();
    } else {
        AudioManager::playLose();
    }
}

// 5. 应用进入后台
void AppDelegate::applicationDidEnterBackground() {
    AudioManager::pauseAll();
}

void AppDelegate::applicationWillEnterForeground() {
    AudioManager::resumeAll();
}
```

---

## 本章小结

1. **AudioManager** 封装所有音频操作
2. **BGM/SFX 分离** 支持独立控制
3. **预加载** 减少播放延迟
4. **静音设置** 持久化到 UserDefault
5. **跨平台** 注意文件路径大小写

---

## 练习题

1. 添加音量渐变效果：BGM 切换时淡入淡出
2. 实现音效随机音调：同一音效略微变调增加变化
3. 添加振动反馈：Android 端按钮点击时震动

---

**下一章**：[第14章 存档系统完整实现](第14章-存档系统完整实现.md)
