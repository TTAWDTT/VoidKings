# 第20章 代码阅读与调试技巧

> **本章目标**：掌握高效阅读代码的方法和常用调试技巧。

---

## 20.1 代码导航

### 20.1.1 VS 跳转到定义

在 Visual Studio 中快速导航：

| 快捷键 | 功能 |
|--------|------|
| **F12** | 跳转到定义 |
| **Ctrl+F12** | 跳转到声明 |
| **Alt+F12** | 速览定义（弹窗预览） |
| **Ctrl+-** | 导航后退 |
| **Ctrl+Shift+-** | 导航前进 |

**使用示例**：
```cpp
auto sprite = Sprite::create("player.png");  // 光标在 create 上
// 按 F12 跳转到 Sprite::create() 的实现
```

### 20.1.2 查找所有引用

| 快捷键 | 功能 |
|--------|------|
| **Shift+F12** | 查找所有引用 |
| **Ctrl+K, Ctrl+R** | 查找所有引用（带预览） |

**使用场景**：
- 查看某个函数被哪些地方调用
- 查看某个变量在哪里被修改
- 重构前评估影响范围

### 20.1.3 调用层次视图

| 快捷键 | 功能 |
|--------|------|
| **Ctrl+K, Ctrl+T** | 查看调用层次结构 |

```
调用 getCurrentATK() 的位置
├── DefenceBuilding::attackTarget()
├── BattleScene::showBuildingInfo()
└── IDCardPanel::updateDetail()

getCurrentATK() 调用的函数
└── getConfig() → MAXLEVEL
```

---

## 20.2 日志系统使用

### 20.2.1 CCLOG 宏

```cpp
// 基本使用
CCLOG("简单消息");

// 格式化输出
CCLOG("玩家位置: (%.2f, %.2f)", pos.x, pos.y);
CCLOG("士兵 ID: %d, HP: %.0f", soldier->getId(), soldier->getHP());

// 只在 Debug 模式有效
#if COCOS2D_DEBUG > 0
    CCLOG("调试信息");
#endif
```

### 20.2.2 日志分层命名

使用统一的前缀便于过滤：

```cpp
// 按模块分类
CCLOG("[Core] 资源变化: COIN +%d", amount);
CCLOG("[Battle] 战斗开始: level=%d", levelId);
CCLOG("[Save] 存档加载: slot=%d", slot);
CCLOG("[Share] 快照导出完成");
CCLOG("[UI] 面板打开: TrainPanel");

// 过滤特定模块
// Windows: 输出窗口搜索 "[Battle]"
// Android: adb logcat | findstr "[Battle]"
```

### 20.2.3 条件日志

```cpp
// 只在特定条件下输出
void Soldier::update(float dt) {
    #if VERBOSE_LOG
    CCLOG("[Soldier] update: id=%d, hp=%.0f, state=%d",
          _id, _currentHP, static_cast<int>(_state));
    #endif
}

// 使用宏控制
#define LOG_BATTLE 1
#define LOG_SAVE 0

#if LOG_BATTLE
    CCLOG("[Battle] ...");
#endif
```

---

## 20.3 常见问题排查

### 20.3.1 空指针崩溃

**症状**：
```
Exception: Access violation reading location 0x00000000
```

**排查步骤**：
1. 查看调用堆栈，定位崩溃位置
2. 检查空指针来源
3. 添加防御性检查

```cpp
// 问题代码
void Soldier::update(float dt) {
    _target->getPosition();  // _target 可能为 nullptr
}

// 修复后
void Soldier::update(float dt) {
    if (!_target) {
        _target = findNewTarget();
        return;
    }
    _target->getPosition();
}

// 更安全的写法
void Soldier::update(float dt) {
    if (!_target || !_target->getParent()) {
        return;
    }
    // 现在可以安全使用 _target
}
```

### 20.3.2 资源加载失败

**症状**：
```
[FileUtils] File not found: xxx.png
```

**排查步骤**：
1. 检查文件是否存在
2. 检查路径大小写（特别是 Android）
3. 检查搜索路径配置

```cpp
// 调试资源路径
auto fileUtils = FileUtils::getInstance();
std::string fullPath = fileUtils->fullPathForFilename("player.png");
CCLOG("[Debug] 完整路径: %s", fullPath.c_str());

// 检查文件是否存在
if (fileUtils->isFileExist("player.png")) {
    CCLOG("[Debug] 文件存在");
} else {
    CCLOG("[Debug] 文件不存在！");
}
```

### 20.3.3 动画不播放

**可能原因**：
1. 动画帧文件不存在
2. 帧数配置错误
3. Sprite 被移除或隐藏
4. 动画被其他动作覆盖

```cpp
// 调试动画加载
void debugAnimation(const std::string& baseName, 
                     const std::string& animKey, 
                     int frameCount) {
    for (int i = 1; i <= frameCount; ++i) {
        std::string name = StringUtils::format("%s_%s_%d.png",
            baseName.c_str(), animKey.c_str(), i);
        
        auto texture = Director::getInstance()
            ->getTextureCache()->addImage(name);
        
        if (texture) {
            CCLOG("[Anim] ✓ 帧 %d: %s", i, name.c_str());
        } else {
            CCLOG("[Anim] ✗ 帧 %d 加载失败: %s", i, name.c_str());
        }
    }
}
```

### 20.3.4 触摸无响应

**可能原因**：
1. 被其他节点遮挡（检查 zOrder）
2. 触摸监听器未注册
3. 节点不可见或透明
4. 触摸被吞噬

```cpp
// 调试触摸
auto listener = EventListenerTouchOneByOne::create();
listener->onTouchBegan = [](Touch* touch, Event* event) -> bool {
    CCLOG("[Touch] 触摸位置: (%.0f, %.0f)", 
          touch->getLocation().x, touch->getLocation().y);
    return true;
};

// 检查节点状态
void debugNode(Node* node) {
    CCLOG("[Debug] 节点: %s", node->getName().c_str());
    CCLOG("[Debug]   visible: %d", node->isVisible());
    CCLOG("[Debug]   opacity: %d", node->getOpacity());
    CCLOG("[Debug]   position: (%.0f, %.0f)", 
          node->getPositionX(), node->getPositionY());
    CCLOG("[Debug]   size: (%.0f, %.0f)", 
          node->getContentSize().width, node->getContentSize().height);
    CCLOG("[Debug]   zOrder: %d", node->getLocalZOrder());
}
```

---

## 调试工具箱

```cpp
// Utils/DebugUtils.h
namespace DebugUtils {
    // 输出节点树
    void printNodeTree(Node* root, int depth = 0);
    
    // 高亮节点边界
    void highlightBounds(Node* node, Color4F color = Color4F::RED);
    
    // 暂停并等待
    void pauseForDebug();
    
    // 性能计时
    class Timer {
        std::chrono::high_resolution_clock::time_point start;
        std::string name;
    public:
        Timer(const std::string& name);
        ~Timer();  // 析构时输出耗时
    };
}

// 使用示例
{
    DebugUtils::Timer timer("战斗更新");
    // ... 代码 ...
}  // 离开作用域时自动输出耗时
```

---

## 本章小结

1. **代码导航** 使用 F12、Shift+F12 快速定位
2. **日志分层** 使用 `[模块名]` 前缀便于过滤
3. **空指针** 是最常见的崩溃原因，做好防御性检查
4. **资源问题** 检查路径和大小写
5. **调试工具** 封装常用的调试函数

---

## 练习题

1. 为项目添加 `DebugUtils` 工具类
2. 使用条件断点调试特定情况
3. 编写单元测试验证关键逻辑

---

**下一章**：[第21章 新功能开发实战](第21章-新功能开发实战.md)
