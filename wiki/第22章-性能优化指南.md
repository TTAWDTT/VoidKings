# 第22章 性能优化指南

> **本章目标**：掌握游戏性能优化的核心技术，提升游戏流畅度。

---

## 22.1 渲染优化

### 22.1.1 批次合并

Cocos2d-x 会自动合并使用相同纹理的绘制调用：

```cpp
// 查看当前绘制调用数
Director::getInstance()->setDisplayStats(true);
// 显示：GL verts / GL calls

// 优化前（每个精灵一次绘制）：
// GL calls: 100

// 优化后（批次合并）：
// GL calls: 5
```

**最佳实践**：
1. 使用纹理图集（Sprite Sheet）
2. 相同纹理的精灵放在相邻层级
3. 避免频繁切换纹理

### 22.1.2 纹理图集

将多个小图合并为大图：

```cpp
// 加载纹理图集
SpriteFrameCache::getInstance()->addSpriteFramesWithFile("units.plist");

// 从图集创建精灵
auto sprite = Sprite::createWithSpriteFrameName("soldier_idle_1.png");
```

**工具推荐**：
- TexturePacker
- Zwoptex
- Shoebox

### 22.1.3 裁剪与视锥剔除

只渲染可见区域内的对象：

```cpp
// 手动剔除屏幕外的对象
void BattleScene::update(float dt) {
    Rect visibleRect = getVisibleRect();
    
    for (auto* soldier : _soldiers) {
        if (soldier) {
            Rect bounds = soldier->getBoundingBox();
            
            // 如果完全在屏幕外
            if (!visibleRect.intersectsRect(bounds)) {
                soldier->setVisible(false);  // 不渲染
            } else {
                soldier->setVisible(true);
            }
        }
    }
}
```

---

## 22.2 内存优化

### 22.2.1 对象池模式

避免频繁创建和销毁对象：

```cpp
// Classes/Utils/ObjectPool.h
template<typename T>
class ObjectPool {
public:
    static ObjectPool& getInstance() {
        static ObjectPool instance;
        return instance;
    }
    
    T* acquire() {
        if (_available.empty()) {
            T* obj = T::create();
            if (obj) obj->retain();
            return obj;
        }
        
        T* obj = _available.back();
        _available.pop_back();
        return obj;
    }
    
    void release(T* obj) {
        if (obj) {
            obj->reset();  // 重置状态
            _available.push_back(obj);
        }
    }
    
    void clear() {
        for (auto* obj : _available) {
            if (obj) obj->release();
        }
        _available.clear();
    }

private:
    std::vector<T*> _available;
};

// 使用示例
auto* bullet = ObjectPool<Bullet>::getInstance().acquire();
bullet->init(damage, speed);
bulletLayer->addChild(bullet);

// 回收
void Bullet::onReachTarget() {
    this->removeFromParent();
    ObjectPool<Bullet>::getInstance().release(this);
}
```

### 22.2.2 纹理压缩

使用压缩格式减少显存占用：

| 格式 | 压缩比 | 质量 | 平台 |
|------|--------|------|------|
| PNG | 无压缩 | 最高 | 全平台 |
| PVR | 8:1 | 中 | iOS |
| ETC1 | 6:1 | 中 | Android |
| ETC2 | 6:1 | 高 | Android 4.3+ |

```cpp
// 根据平台选择纹理
#if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID)
    auto texture = Director::getInstance()->getTextureCache()
        ->addImage("textures/units.pkm");  // ETC 格式
#else
    auto texture = Director::getInstance()->getTextureCache()
        ->addImage("textures/units.png");
#endif
```

### 22.2.3 及时释放资源

```cpp
// 场景切换时清理缓存
void BattleScene::onExit() {
    Scene::onExit();
    
    // 清理特定缓存
    Director::getInstance()->getTextureCache()
        ->removeUnusedTextures();
    
    SpriteFrameCache::getInstance()
        ->removeUnusedSpriteFrames();
    
    AnimationCache::getInstance()
        ->destroyInstance();
}
```

---

## 22.3 逻辑优化

### 22.3.1 空间分区

使用网格分区加速碰撞检测：

```cpp
// 简单的网格分区
class SpatialGrid {
public:
    void insert(Node* obj, const Vec2& pos);
    void remove(Node* obj);
    void update(Node* obj, const Vec2& oldPos, const Vec2& newPos);
    
    std::vector<Node*> queryNear(const Vec2& pos, float radius);
    
private:
    static constexpr int CELL_SIZE = 64;
    std::unordered_map<int, std::vector<Node*>> _cells;
    
    int getCellKey(const Vec2& pos) {
        int cx = static_cast<int>(pos.x / CELL_SIZE);
        int cy = static_cast<int>(pos.y / CELL_SIZE);
        return cy * 10000 + cx;
    }
};

// 使用空间分区查找目标
Soldier* DefenceBuilding::findTarget() {
    // 之前：遍历所有士兵 O(n)
    // for (auto* soldier : *s_enemySoldiers) { ... }
    
    // 现在：只检查附近区域 O(k) where k << n
    auto nearby = _spatialGrid->queryNear(
        this->getPosition(), 
        getAttackRange() + 50  // 稍大范围
    );
    
    for (auto* node : nearby) {
        auto* soldier = dynamic_cast<Soldier*>(node);
        if (soldier && canTarget(soldier)) {
            return soldier;
        }
    }
    
    return nullptr;
}
```

### 22.3.2 更新频率控制

不是所有逻辑都需要每帧执行：

```cpp
void Soldier::update(float dt) {
    // 每帧执行：移动
    moveToTarget(dt);
    
    // 每 0.25 秒执行：寻敌
    _targetRefreshTimer += dt;
    if (_targetRefreshTimer >= 0.25f) {
        _targetRefreshTimer = 0.0f;
        refreshTarget();
    }
    
    // 每 1 秒执行：AI 决策
    _aiTimer += dt;
    if (_aiTimer >= 1.0f) {
        _aiTimer = 0.0f;
        updateAI();
    }
}
```

### 22.3.3 算法复杂度

优化关键算法：

```cpp
// 优化前：O(n²) 碰撞检测
for (auto* soldier : soldiers) {
    for (auto* building : buildings) {
        if (collides(soldier, building)) {
            // 处理碰撞
        }
    }
}

// 优化后：O(n log n) 使用空间分区
for (auto* soldier : soldiers) {
    auto nearby = spatialGrid.queryNear(
        soldier->getPosition(), 
        soldier->getAttackRange()
    );
    
    for (auto* building : nearby) {
        if (collides(soldier, building)) {
            // 处理碰撞
        }
    }
}
```

---

## 性能分析工具

### 内置统计

```cpp
// 显示性能统计
Director::getInstance()->setDisplayStats(true);

// 显示内容：
// - FPS：帧率
// - GL verts：顶点数
// - GL calls：绘制调用数
```

### 自定义计时器

```cpp
class ProfileTimer {
public:
    ProfileTimer(const char* name) : _name(name) {
        _start = std::chrono::high_resolution_clock::now();
    }
    
    ~ProfileTimer() {
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>
            (end - _start).count();
        CCLOG("[Profile] %s: %lld μs", _name, duration);
    }
    
private:
    const char* _name;
    std::chrono::high_resolution_clock::time_point _start;
};

// 使用
void BattleScene::update(float dt) {
    {
        ProfileTimer timer("updateSoldiers");
        updateSoldiers(dt);
    }
    
    {
        ProfileTimer timer("updateBuildings");
        updateBuildings(dt);
    }
}
```

---

## 优化清单

| 类别 | 优化项 | 效果 |
|------|--------|------|
| 渲染 | 纹理图集 | 减少 80% GL calls |
| 渲染 | 批次合并 | 提升 FPS |
| 渲染 | 视锥剔除 | 减少 50% 绘制 |
| 内存 | 对象池 | 减少 GC 卡顿 |
| 内存 | 纹理压缩 | 减少 60% 显存 |
| 内存 | 及时释放 | 避免内存泄漏 |
| 逻辑 | 空间分区 | O(n²) → O(n log n) |
| 逻辑 | 更新间隔 | 减少 CPU 占用 |

---

## 本章小结

1. **渲染优化**：使用纹理图集、批次合并、视锥剔除
2. **内存优化**：对象池、纹理压缩、及时释放
3. **逻辑优化**：空间分区、降低更新频率、优化算法
4. **性能分析**：使用内置统计和自定义计时器定位瓶颈

---

## 练习题

1. 为子弹实现对象池
2. 使用空间分区优化防御塔寻敌
3. 添加性能监控面板

---

**附录**：[附录A-完整类图](附录A-完整类图.md)
