# 第5章 建筑系统完整实现

> **本章目标**：深入理解 VoidKings 的建筑系统，包括配置加载、防御建筑战斗逻辑、生产建筑资源收集等。

---

## 5.1 建筑配置数据驱动

### 5.1.1 JSON 配置文件结构分析

所有建筑数据存储在 `Resources/res/buildings_config.json`：

```json
{
  "defenceBuildings": [
    {
      "id": 1001,
      "name": "ArrowTower",
      "HP": [100, 120, 150, 180, 220],
      "ATK": [15, 20, 25, 32, 40],
      "ATK_SPEED": [1.0, 0.95, 0.9, 0.85, 0.8],
      "ATK_RANGE": [150, 160, 170, 180, 200],
      "width": 3,
      "length": 3,
      "MAXLEVEL": 4,
      "GROUND_ABLE": true,
      "SKY_ABLE": true,
      "spritePath": "buildings/ArrowTower/arrow_tower.png",
      "bulletSprite": "buildings/ArrowTower/arrow.png",
      "bulletSpeed": 300
    }
  ],
  "productionBuildings": [
    {
      "id": 3001,
      "name": "MainBase",
      "HP": [500, 600, 750, 900],
      "width": 4,
      "length": 4,
      "MAXLEVEL": 3,
      "PRODUCE_GOLD": [0, 0, 0, 0],
      "PRODUCE_ELIXIR": [0, 0, 0, 0],
      "isMainBase": true
    },
    {
      "id": 3003,
      "name": "GoldMine",
      "HP": [80, 100, 120],
      "width": 3,
      "length": 3,
      "MAXLEVEL": 2,
      "PRODUCE_GOLD": [5, 8, 12],
      "PRODUCE_ELIXIR": [0, 0, 0]
    }
  ]
}
```

**关键字段说明**：

| 字段 | 类型 | 说明 |
|------|------|------|
| id | int | 唯一标识符 |
| name | string | 建筑名称 |
| HP | array | 各等级血量 |
| ATK | array | 各等级攻击力（仅防御建筑） |
| ATK_SPEED | array | 攻击间隔（秒） |
| ATK_RANGE | array | 攻击范围（像素） |
| width/length | int | 占地格子数 |
| MAXLEVEL | int | 最大等级索引（从0开始） |

### 5.1.2 RapidJSON 解析流程

```cpp
// Classes/Buildings/BuildingManager.cpp
#include "json/document.h"
#include "json/stringbuffer.h"

bool BuildingManager::loadConfigs() {
    // 1. 读取 JSON 文件
    std::string jsonData = FileUtils::getInstance()
        ->getStringFromFile("res/buildings_config.json");
    
    if (jsonData.empty()) {
        CCLOG("[BuildingManager] 配置文件为空或不存在");
        return false;
    }
    
    // 2. 处理 UTF-8 BOM
    if (jsonData.size() >= 3 &&
        static_cast<unsigned char>(jsonData[0]) == 0xEF &&
        static_cast<unsigned char>(jsonData[1]) == 0xBB &&
        static_cast<unsigned char>(jsonData[2]) == 0xBF) {
        jsonData = jsonData.substr(3);
    }
    
    // 3. 解析 JSON
    rapidjson::Document doc;
    doc.Parse(jsonData.c_str());
    
    if (doc.HasParseError()) {
        CCLOG("[BuildingManager] JSON 解析错误: %d",
              doc.GetParseError());
        return false;
    }
    
    // 4. 解析防御建筑
    if (doc.HasMember("defenceBuildings") && 
        doc["defenceBuildings"].IsArray()) {
        for (auto& item : doc["defenceBuildings"].GetArray()) {
            parseDefenceConfig(item);
        }
    }
    
    // 5. 解析生产建筑
    if (doc.HasMember("productionBuildings") && 
        doc["productionBuildings"].IsArray()) {
        for (auto& item : doc["productionBuildings"].GetArray()) {
            parseProductionConfig(item);
        }
    }
    
    return true;
}

void BuildingManager::parseDefenceConfig(const rapidjson::Value& item) {
    DefenceConfig config;
    
    config.id = item["id"].GetInt();
    config.name = item["name"].GetString();
    config.width = item["width"].GetInt();
    config.length = item["length"].GetInt();
    config.MAXLEVEL = item["MAXLEVEL"].GetInt();
    
    // 解析数组属性
    if (item.HasMember("HP") && item["HP"].IsArray()) {
        for (auto& v : item["HP"].GetArray()) {
            config.HP.push_back(v.GetFloat());
        }
    }
    
    if (item.HasMember("ATK") && item["ATK"].IsArray()) {
        for (auto& v : item["ATK"].GetArray()) {
            config.ATK.push_back(v.GetFloat());
        }
    }
    
    // ... 解析其他字段
    
    // 存入映射
    _defenceConfigs[config.id] = config;
}
```

### 5.1.3 配置热加载实现

```cpp
// 重新加载配置（开发调试用）
void BuildingManager::reloadConfigs() {
    _defenceConfigs.clear();
    _productionConfigs.clear();
    loadConfigs();
    CCLOG("[BuildingManager] 配置已重新加载");
}
```

### 5.1.4 UTF-8 BOM 处理

Windows 记事本保存的 UTF-8 文件可能带有 BOM（字节顺序标记）：

```cpp
// BOM 字节序列：EF BB BF
if (jsonData.size() >= 3 &&
    static_cast<unsigned char>(jsonData[0]) == 0xEF &&
    static_cast<unsigned char>(jsonData[1]) == 0xBB &&
    static_cast<unsigned char>(jsonData[2]) == 0xBF) {
    jsonData = jsonData.substr(3);  // 跳过 BOM
}
```

不处理 BOM 会导致 JSON 解析失败。

---

## 5.2 防御建筑 DefenceBuilding 实现

### 5.2.1 类继承结构设计

```cpp
// Classes/Buildings/DefenceBuilding.h
class DefenceBuilding : public Node {
public:
    static DefenceBuilding* create(const DefenceConfig* config, int level);
    bool init(const DefenceConfig* config, int level);
    void update(float dt) override;
    
    // 状态查询
    bool isDestroyed() const { return _currentHP <= 0; }
    float getCurrentHP() const { return _currentHP; }
    float getCurrentMaxHP() const;
    float getCurrentATK() const;
    float getCurrentATK_RANGE() const;
    
    // 受伤
    void takeDamage(float damage);
    
private:
    const DefenceConfig* _config;  // 配置模板（享元）
    int _level;                     // 当前等级
    float _currentHP;               // 当前血量
    float _attackTimer;             // 攻击计时器
    Node* _target;                  // 当前目标
    
    Sprite* _bodySprite;            // 主贴图
    Node* _healthBar;               // 血条
};
```

### 5.2.2 初始化流程 init() 解析

```cpp
bool DefenceBuilding::init(const DefenceConfig* config, int level) {
    if (!Node::init()) return false;
    
    _config = config;
    _level = std::min(level, config->MAXLEVEL);
    _currentHP = getCurrentMaxHP();
    _attackTimer = 0.0f;
    _target = nullptr;
    
    // 1. 创建主贴图
    _bodySprite = Sprite::create(config->spritePath);
    if (_bodySprite) {
        _bodySprite->setName("bodySprite");
        this->addChild(_bodySprite, 0);
    }
    
    // 2. 创建血条
    createHealthBar();
    
    // 3. 启动 update 循环
    this->scheduleUpdate();
    
    return true;
}
```

### 5.2.3 血条 UI 创建与更新

```cpp
void DefenceBuilding::createHealthBar() {
    // 血条容器
    _healthBar = Node::create();
    _healthBar->setName("healthBar");
    
    // 背景（灰色）
    auto bgSprite = Sprite::create("res/health_bar_bg.png");
    bgSprite->setName("bg");
    _healthBar->addChild(bgSprite, 0);
    
    // 前景（绿色→红色渐变）
    auto fgSprite = Sprite::create("res/health_bar.png");
    fgSprite->setName("fg");
    fgSprite->setAnchorPoint(Vec2(0, 0.5f));  // 左对齐
    fgSprite->setPositionX(-bgSprite->getContentSize().width / 2);
    _healthBar->addChild(fgSprite, 1);
    
    // 放置在建筑上方
    float yOffset = _bodySprite ? 
        _bodySprite->getContentSize().height * 0.6f : 50.0f;
    _healthBar->setPosition(Vec2(0, yOffset));
    
    this->addChild(_healthBar, 100);
}

void DefenceBuilding::updateHealthBar(bool animate) {
    auto fgSprite = dynamic_cast<Sprite*>(
        _healthBar->getChildByName("fg"));
    if (!fgSprite) return;
    
    float ratio = _currentHP / getCurrentMaxHP();
    ratio = std::max(0.0f, std::min(1.0f, ratio));
    
    // 更新宽度比例
    if (animate) {
        fgSprite->stopAllActions();
        fgSprite->runAction(ScaleTo::create(0.2f, ratio, 1.0f));
    } else {
        fgSprite->setScaleX(ratio);
    }
    
    // 根据血量改变颜色
    if (ratio > 0.5f) {
        fgSprite->setColor(Color3B::GREEN);
    } else if (ratio > 0.25f) {
        fgSprite->setColor(Color3B::YELLOW);
    } else {
        fgSprite->setColor(Color3B::RED);
    }
}
```

### 5.2.4 受伤闪白特效实现

```cpp
void DefenceBuilding::takeDamage(float damage) {
    if (isDestroyed()) return;
    
    _currentHP -= damage;
    updateHealthBar(true);
    
    // 闪白效果
    if (_bodySprite) {
        _bodySprite->stopActionByTag(TAG_HIT_FLASH);
        
        auto tintTo = TintTo::create(0.05f, 255, 255, 255);
        auto tintBack = TintTo::create(0.1f, 255, 255, 255);
        auto action = Sequence::create(
            TintTo::create(0.0f, 255, 200, 200),  // 变红
            DelayTime::create(0.05f),
            TintTo::create(0.1f, 255, 255, 255),  // 恢复
            nullptr
        );
        action->setTag(TAG_HIT_FLASH);
        _bodySprite->runAction(action);
    }
    
    // 检查是否死亡
    if (_currentHP <= 0) {
        _currentHP = 0;
        onDestroyed();
    }
}

void DefenceBuilding::onDestroyed() {
    // 停止攻击
    this->unscheduleUpdate();
    
    // 播放爆炸音效
    AudioManager::playBuildingCollapse();
    
    // 播放死亡动画
    if (_bodySprite) {
        auto fade = FadeOut::create(0.3f);
        auto scale = ScaleTo::create(0.3f, 0.5f);
        auto spawn = Spawn::create(fade, scale, nullptr);
        auto sequence = Sequence::create(
            spawn,
            CallFunc::create([this]() {
                this->removeFromParent();
            }),
            nullptr
        );
        _bodySprite->runAction(sequence);
    }
}
```

---

## 5.3 防御建筑战斗逻辑

### 5.3.1 update(float dt) 主循环

```cpp
void DefenceBuilding::update(float dt) {
    if (isDestroyed()) return;
    
    // 更新攻击计时器
    _attackTimer += dt;
    
    // 检查当前目标是否有效
    if (!isTargetValid()) {
        _target = nullptr;
    }
    
    // 寻找新目标
    if (!_target) {
        _target = findTarget();
    }
    
    // 攻击逻辑
    if (_target && _attackTimer >= getCurrentATK_SPEED()) {
        attackTarget();
        _attackTimer = 0.0f;
    }
}
```

### 5.3.2 目标寻找算法 findTarget()

```cpp
Soldier* DefenceBuilding::findTarget() {
    if (!s_enemySoldiers || s_enemySoldiers->empty()) {
        return nullptr;
    }
    
    float myRange = getCurrentATK_RANGE();
    Vec2 myPos = this->getPosition();
    
    Soldier* nearest = nullptr;
    float nearestDist = FLT_MAX;
    
    for (Soldier* soldier : *s_enemySoldiers) {
        if (!soldier || !soldier->getParent()) continue;
        if (soldier->isDead()) continue;
        
        // 检查目标类型过滤
        if (!canTargetSoldier(soldier)) continue;
        
        // 计算距离
        Vec2 soldierPos = soldier->getPosition();
        float dist = myPos.distance(soldierPos);
        
        // 检查是否在攻击范围内
        if (dist <= myRange && dist < nearestDist) {
            nearestDist = dist;
            nearest = soldier;
        }
    }
    
    return nearest;
}
```

### 5.3.3 攻击判定与伤害计算

```cpp
void DefenceBuilding::attackTarget() {
    if (!_target) return;
    
    // 播放攻击动画
    playAttackAnimation();
    
    // 创建子弹
    auto bullet = Bullet::create(
        _config->bulletSprite,
        getCurrentATK(),
        _config->bulletSpeed
    );
    
    if (bullet) {
        bullet->setPosition(this->getPosition());
        bullet->setTarget(_target);
        this->getParent()->addChild(bullet, 50);
    }
    
    // 播放音效
    playAttackSound();
}

void DefenceBuilding::playAttackSound() {
    switch (_config->type) {
        case TowerType::ARROW:
            AudioManager::playArrowShoot();
            break;
        case TowerType::BOOM:
            AudioManager::playBoom();
            break;
        case TowerType::MAGIC:
            AudioManager::playMagicAttack();
            break;
        case TowerType::FIRE:
            AudioManager::playFireSpray();
            break;
    }
}
```

### 5.3.4 空中/地面目标过滤

```cpp
bool DefenceBuilding::canTargetSoldier(const Soldier* soldier) const {
    if (!soldier) return false;
    
    if (soldier->isFlying()) {
        // 飞行单位：检查 SKY_ABLE
        return _config->SKY_ABLE;
    } else {
        // 地面单位：检查 GROUND_ABLE
        return _config->GROUND_ABLE;
    }
}
```

---

## 5.4 特殊建筑类型实现

### 5.4.1 魔法塔：命中特效生成

```cpp
// 魔法塔子弹命中时
void MagicBullet::onReachTarget() {
    Bullet::onReachTarget();
    
    // 生成魔法爆炸特效
    auto effect = ParticleSystemQuad::create("effects/magic_hit.plist");
    if (effect) {
        effect->setPosition(this->getPosition());
        effect->setAutoRemoveOnFinish(true);
        this->getParent()->addChild(effect, 100);
    }
    
    // 对目标造成伤害
    if (_target) {
        auto soldier = dynamic_cast<Soldier*>(_target);
        if (soldier) {
            soldier->takeDamage(_damage);
        }
    }
}
```

### 5.4.2 火焰塔：持续伤害机制

```cpp
// 火焰塔不发射子弹，而是持续造成范围伤害
void FireTower::update(float dt) {
    if (isDestroyed()) return;
    
    _damageTimer += dt;
    
    // 每 0.5 秒造成一次伤害
    if (_damageTimer >= 0.5f) {
        dealAreaDamage();
        _damageTimer = 0.0f;
    }
}

void FireTower::dealAreaDamage() {
    if (!s_enemySoldiers) return;
    
    Vec2 myPos = this->getPosition();
    float range = getCurrentATK_RANGE();
    float damage = getCurrentATK() * 0.5f;  // 持续伤害较低
    
    for (Soldier* soldier : *s_enemySoldiers) {
        if (!soldier || soldier->isDead()) continue;
        
        Vec2 soldierPos = soldier->getPosition();
        if (myPos.distance(soldierPos) <= range) {
            soldier->takeDamage(damage);
        }
    }
}
```

---

## 5.5 生产建筑 ProductionBuilding

### 5.5.1 资源生产计时器

```cpp
// Classes/Buildings/ProductionBuilding.cpp
void ProductionBuilding::update(float dt) {
    if (isDestroyed()) return;
    
    // 累积生产时间
    _produceTimer += dt;
    
    // 计算实际生产间隔（受基地等级影响）
    float interval = getProduceInterval();
    
    if (_produceTimer >= interval) {
        _produceTimer = 0.0f;
        produceResource();
    }
}

float ProductionBuilding::getProduceInterval() const {
    // 基础间隔 10 秒
    float baseInterval = 10.0f;
    
    // 应用基地等级加成
    float multiplier = Core::getInstance()->getBaseProduceSpeedMultiplier();
    
    return baseInterval / multiplier;  // 等级越高，间隔越短
}

void ProductionBuilding::produceResource() {
    int gold = getCurrentPRODUCE_GOLD();
    int elixir = getCurrentPRODUCE_ELIXIR();
    
    if (gold > 0) {
        _storedGold += gold;
        _storedGold = std::min(_storedGold, _maxStorage);
    }
    
    if (elixir > 0) {
        _storedElixir += elixir;
        _storedElixir = std::min(_storedElixir, _maxStorage);
    }
    
    // 显示收集图标
    if (_storedGold > 0 || _storedElixir > 0) {
        showCollectIcon();
    }
}
```

### 5.5.2 收集逻辑与动画

```cpp
void ProductionBuilding::collect() {
    if (_storedGold <= 0 && _storedElixir <= 0) return;
    
    // 通知场景播放收集动画
    if (_onCollect) {
        _onCollect(this->getPosition(), 
                   ResourceType::COIN, _storedGold);
        _onCollect(this->getPosition(), 
                   ResourceType::DIAMOND, _storedElixir);
    }
    
    // 清空存储
    _storedGold = 0;
    _storedElixir = 0;
    
    // 隐藏收集图标
    hideCollectIcon();
}
```

---

## 本章小结

1. **JSON 配置驱动** 所有建筑数据，便于修改和扩展
2. **DefenceBuilding** 实现完整的战斗逻辑：寻敌→攻击→特效
3. **血条 UI** 随血量动态变化颜色和长度
4. **不同塔类型** 有不同的攻击方式（子弹/范围）
5. **ProductionBuilding** 定时生产并累积资源

---

## 练习题

1. 添加一种新的防御塔类型（如冰冻塔，减速敌人）
2. 实现建筑升级功能：消耗资源提升等级
3. 给防御塔添加攻击范围圆圈显示

---

**下一章**：[第6章 陷阱系统实现](第06章-陷阱系统实现.md)
