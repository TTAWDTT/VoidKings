# 第6章 陷阱系统实现

> **本章目标**：理解 VoidKings 陷阱系统的设计，掌握地刺和夹子陷阱的触发机制与实现原理。

---

## 6.1 陷阱基类 TrapBase 设计

### 6.1.1 敌方士兵列表注入

陷阱需要检测敌方士兵是否进入触发区域，因此需要访问士兵列表：

```cpp
// Classes/Buildings/Trap.h
class TrapBase : public Node {
public:
    // 静态方法：设置敌方士兵列表（在战斗开始时调用）
    static void setEnemySoldiers(const std::vector<Soldier*>* soldiers);
    static void clearEnemySoldiersIf(const std::vector<Soldier*>* soldiers);
    
    // 设置网格上下文（放置时调用）
    void setGridContext(GridMap* gridMap, int gridX, int gridY, 
                        int width, int height);

protected:
    // 初始化陷阱基础属性
    bool initTrapBase(const std::string& firstFrame,
                      const std::string& framePrefix,
                      int frameStart, int frameEnd,
                      float frameDelay, bool loop);
    
    // 获取触发区域（世界坐标矩形）
    Rect getTriggerRect() const;
    
    // 获取士兵在陷阱本地坐标系中的位置
    Vec2 getSoldierLocalPos(const Soldier* soldier) const;
    
    // 释放占用的网格
    void freeGridIfNeeded();

protected:
    GridMap* _gridMap = nullptr;
    int _gridX = 0;
    int _gridY = 0;
    int _gridWidth = 0;
    int _gridHeight = 0;
    bool _gridBound = false;
    bool _gridFreed = false;
    
    Sprite* _bodySprite = nullptr;
    
    // 静态成员：所有陷阱共享同一士兵列表引用
    static const std::vector<Soldier*>* s_enemySoldiers;

    void onExit() override;
};
```

### 6.1.2 网格上下文绑定

陷阱放置时需要记录其在网格中的位置：

```cpp
// Classes/Buildings/Trap.cpp
void TrapBase::setGridContext(GridMap* gridMap, int gridX, int gridY, 
                               int width, int height) {
    _gridMap = gridMap;
    _gridX = gridX;
    _gridY = gridY;
    _gridWidth = width;
    _gridHeight = height;
    _gridBound = true;
    _gridFreed = false;
}

void TrapBase::freeGridIfNeeded() {
    if (_gridFreed || !_gridBound || !_gridMap) return;
    
    // 释放占用的格子
    _gridMap->freeCell(_gridX, _gridY, _gridWidth, _gridHeight);
    _gridFreed = true;
}

void TrapBase::onExit() {
    freeGridIfNeeded();
    Node::onExit();
}
```

### 6.1.3 触发区域计算

```cpp
Rect TrapBase::getTriggerRect() const {
    if (!_gridMap) return Rect::ZERO;
    
    float cellSize = _gridMap->getCellSize();
    
    // 计算世界坐标矩形
    float x = _gridX * cellSize;
    float y = _gridY * cellSize;
    float w = _gridWidth * cellSize;
    float h = _gridHeight * cellSize;
    
    return Rect(x, y, w, h);
}

Vec2 TrapBase::getSoldierLocalPos(const Soldier* soldier) const {
    if (!soldier || !soldier->getParent()) return Vec2::ZERO;
    
    // 将士兵世界坐标转换为陷阱父节点（地图）坐标
    auto* soldierParent = soldier->getParent();
    Vec2 worldPos = soldierParent->convertToWorldSpace(soldier->getPosition());
    
    auto* myParent = this->getParent();
    if (myParent) {
        return myParent->convertToNodeSpace(worldPos);
    }
    return worldPos;
}

bool TrapBase::getSoldierGridPos(const Soldier* soldier, 
                                  int& outX, int& outY) const {
    if (!_gridMap || !soldier) return false;
    
    Vec2 localPos = getSoldierLocalPos(soldier);
    Vec2 gridPos = _gridMap->worldToGrid(localPos);
    
    outX = static_cast<int>(gridPos.x);
    outY = static_cast<int>(gridPos.y);
    return true;
}
```

---

## 6.2 地刺陷阱 SpikeTrap

地刺是**持续伤害型**陷阱：踩上去后每隔一段时间造成伤害。

### 6.2.1 持续伤害定时器

```cpp
// Classes/Buildings/Trap.h
class SpikeTrap : public TrapBase {
public:
    static SpikeTrap* create();
    bool init() override;
    void update(float dt) override;

private:
    float _damageTimer = 0.0f;
    
    static constexpr float DAMAGE_INTERVAL = 0.5f;  // 每 0.5 秒造成伤害
    static constexpr float DAMAGE_AMOUNT = 5.0f;    // 每次伤害值
};
```

### 6.2.2 进入检测算法

```cpp
// Classes/Buildings/Trap.cpp
SpikeTrap* SpikeTrap::create() {
    SpikeTrap* ret = new (std::nothrow) SpikeTrap();
    if (ret && ret->init()) {
        ret->autorelease();
        return ret;
    }
    CC_SAFE_DELETE(ret);
    return nullptr;
}

bool SpikeTrap::init() {
    // 初始化精灵和动画
    if (!initTrapBase("traps/spike/spike_1.png",
                      "traps/spike/spike_",
                      1, 4, 0.15f, true)) {
        return false;
    }
    
    _damageTimer = 0.0f;
    this->scheduleUpdate();
    return true;
}

void SpikeTrap::update(float dt) {
    if (!s_enemySoldiers || s_enemySoldiers->empty()) return;
    
    _damageTimer += dt;
    
    // 检查是否到达伤害间隔
    if (_damageTimer < DAMAGE_INTERVAL) return;
    _damageTimer = 0.0f;
    
    // 获取触发区域
    Rect triggerRect = getTriggerRect();
    
    // 遍历所有士兵
    for (Soldier* soldier : *s_enemySoldiers) {
        if (!soldier || !soldier->getParent()) continue;
        if (soldier->isDead()) continue;
        
        // 获取士兵位置
        Vec2 soldierPos = getSoldierLocalPos(soldier);
        
        // 检查是否在触发区域内
        if (triggerRect.containsPoint(soldierPos)) {
            // 造成伤害
            soldier->takeDamage(DAMAGE_AMOUNT);
        }
    }
}
```

### 6.2.3 伤害音效播放

```cpp
void SpikeTrap::update(float dt) {
    // ... 前面的检测逻辑 ...
    
    bool anyHit = false;
    
    for (Soldier* soldier : *s_enemySoldiers) {
        // ... 检测逻辑 ...
        
        if (triggerRect.containsPoint(soldierPos)) {
            soldier->takeDamage(DAMAGE_AMOUNT);
            anyHit = true;
        }
    }
    
    // 有命中时播放音效
    if (anyHit) {
        AudioManager::playSpikeAppear();
    }
}
```

---

## 6.3 夹子陷阱 SnapTrap

夹子是**一次性触发型**陷阱：触发后造成高额伤害并消失。

### 6.3.1 一次性触发设计

```cpp
// Classes/Buildings/Trap.h
class SnapTrap : public TrapBase {
public:
    static SnapTrap* create();
    bool init() override;
    void update(float dt) override;

private:
    bool _triggered = false;  // 是否已触发
    
    static constexpr float DAMAGE_AMOUNT = 50.0f;  // 触发伤害
    static constexpr float STUN_DURATION = 1.5f;   // 禁锢时间
    
    void triggerOnSoldiers(const std::vector<Soldier*>& soldiers);
};
```

### 6.3.2 禁锢效果实现

```cpp
bool SnapTrap::init() {
    // 初始化精灵（未触发状态）
    _bodySprite = Sprite::create("traps/snap/snap_open.png");
    if (_bodySprite) {
        this->addChild(_bodySprite);
    }
    
    _triggered = false;
    this->scheduleUpdate();
    return true;
}

void SnapTrap::update(float dt) {
    if (_triggered) return;  // 已触发则不再检测
    if (!s_enemySoldiers || s_enemySoldiers->empty()) return;
    
    Rect triggerRect = getTriggerRect();
    std::vector<Soldier*> caughtSoldiers;
    
    // 收集所有在区域内的士兵
    for (Soldier* soldier : *s_enemySoldiers) {
        if (!soldier || !soldier->getParent()) continue;
        if (soldier->isDead()) continue;
        
        Vec2 soldierPos = getSoldierLocalPos(soldier);
        
        if (triggerRect.containsPoint(soldierPos)) {
            caughtSoldiers.push_back(soldier);
        }
    }
    
    // 有士兵进入则触发
    if (!caughtSoldiers.empty()) {
        triggerOnSoldiers(caughtSoldiers);
    }
}

void SnapTrap::triggerOnSoldiers(const std::vector<Soldier*>& soldiers) {
    _triggered = true;
    
    // 停止更新
    this->unscheduleUpdate();
    
    // 播放夹住动画
    if (_bodySprite) {
        auto triggerSprite = Sprite::create("traps/snap/snap_closed.png");
        if (triggerSprite) {
            triggerSprite->setPosition(_bodySprite->getPosition());
            this->addChild(triggerSprite, 1);
            _bodySprite->setVisible(false);
        }
    }
    
    // 播放音效
    AudioManager::playSnapTrap();
    
    // 对所有被抓住的士兵造成伤害和禁锢
    for (Soldier* soldier : soldiers) {
        if (!soldier || soldier->isDead()) continue;
        
        // 造成伤害
        soldier->takeDamage(DAMAGE_AMOUNT);
        
        // 禁锢效果：暂停移动
        soldier->stun(STUN_DURATION);
    }
    
    // 释放网格占用
    freeGridIfNeeded();
    
    // 延迟后移除陷阱
    this->runAction(Sequence::create(
        DelayTime::create(0.5f),
        FadeOut::create(0.3f),
        RemoveSelf::create(),
        nullptr
    ));
}
```

### 6.3.3 触发动画与网格释放

```cpp
void SnapTrap::triggerOnSoldiers(const std::vector<Soldier*>& soldiers) {
    _triggered = true;
    
    // 1. 切换到闭合贴图
    if (_bodySprite) {
        // 播放帧动画
        Vector<SpriteFrame*> frames;
        for (int i = 1; i <= 4; ++i) {
            std::string frameName = StringUtils::format(
                "traps/snap/snap_close_%d.png", i);
            auto texture = Director::getInstance()
                ->getTextureCache()->addImage(frameName);
            if (texture) {
                auto frame = SpriteFrame::createWithTexture(
                    texture, 
                    Rect(0, 0, 
                         texture->getContentSize().width,
                         texture->getContentSize().height));
                frames.pushBack(frame);
            }
        }
        
        if (frames.size() > 0) {
            auto anim = Animation::createWithSpriteFrames(frames, 0.05f);
            _bodySprite->runAction(Animate::create(anim));
        }
    }
    
    // 2. 造成伤害和禁锢
    for (Soldier* soldier : soldiers) {
        if (!soldier || soldier->isDead()) continue;
        soldier->takeDamage(DAMAGE_AMOUNT);
        soldier->stun(STUN_DURATION);
    }
    
    // 3. 释放网格（陷阱消失后格子可再利用）
    freeGridIfNeeded();
    
    // 4. 淡出并移除
    this->runAction(Sequence::create(
        DelayTime::create(STUN_DURATION),  // 等待禁锢结束
        FadeOut::create(0.3f),
        RemoveSelf::create(),
        nullptr
    ));
}
```

---

## 士兵禁锢效果实现

在 `Soldier` 类中需要添加禁锢支持：

```cpp
// Classes/Soldier/Soldier.h
class Soldier : public Node {
public:
    void stun(float duration);
    bool isStunned() const { return _stunTimer > 0.0f; }

private:
    float _stunTimer = 0.0f;
};

// Classes/Soldier/Soldier.cpp
void Soldier::stun(float duration) {
    _stunTimer = duration;
    
    // 视觉反馈：变灰
    if (_bodySprite) {
        _bodySprite->setColor(Color3B(150, 150, 150));
    }
}

void Soldier::update(float dt) {
    // 处理禁锢状态
    if (_stunTimer > 0.0f) {
        _stunTimer -= dt;
        if (_stunTimer <= 0.0f) {
            _stunTimer = 0.0f;
            // 恢复颜色
            if (_bodySprite) {
                _bodySprite->setColor(Color3B::WHITE);
            }
        }
        return;  // 禁锢期间不执行其他逻辑
    }
    
    // 正常逻辑：移动、攻击等
    updateNormalBehavior(dt);
}
```

---

## 陷阱系统架构图

```
┌─────────────────────────────────────────────────────────┐
│                      TrapBase                            │
│  ├─ s_enemySoldiers (静态，共享士兵列表)                  │
│  ├─ _gridMap, _gridX, _gridY (网格信息)                  │
│  ├─ getTriggerRect() → Rect                              │
│  └─ freeGridIfNeeded()                                   │
└───────────────────────┬─────────────────────────────────┘
                        │
        ┌───────────────┴───────────────┐
        │                               │
┌───────▼───────┐               ┌───────▼───────┐
│   SpikeTrap   │               │   SnapTrap    │
├───────────────┤               ├───────────────┤
│ 持续伤害      │               │ 一次性触发    │
│ 不消失        │               │ 禁锢 + 高伤害 │
│ 低伤害/0.5秒  │               │ 触发后消失    │
└───────────────┘               └───────────────┘
```

---

## 陷阱放置流程

```cpp
// BattleScene.cpp 中创建陷阱
void BattleScene::createSpikeTrap(int gridX, int gridY) {
    auto* trap = SpikeTrap::create();
    if (!trap) return;
    
    // 1. 添加到建筑层
    _buildingLayer->addChild(trap);
    
    // 2. 计算世界坐标（格子中心）
    float cellSize = _gridMap->getCellSize();
    float centerX = (gridX + 0.5f) * cellSize;
    float centerY = (gridY + 0.5f) * cellSize;
    trap->setPosition(Vec2(centerX, centerY));
    
    // 3. 缩放适配格子
    scaleBuildingToFit(trap, 1, 1, cellSize);
    
    // 4. 标记网格占用
    _gridMap->occupyCell(gridX, gridY, 1, 1, trap);
    
    // 5. 设置网格上下文（用于触发区域计算）
    trap->setGridContext(_gridMap, gridX, gridY, 1, 1);
}
```

---

## 本章小结

1. **TrapBase** 提供公共功能：网格绑定、触发区域计算、士兵检测
2. **SpikeTrap** 是持续伤害型，每隔一段时间对区域内士兵造成伤害
3. **SnapTrap** 是一次性触发型，造成高伤害和禁锢效果
4. 陷阱触发后需要释放网格占用
5. 士兵需要实现 `stun()` 方法支持禁锢效果

---

## 练习题

1. 添加新陷阱类型：炸弹陷阱（触发后造成范围伤害）
2. 实现陷阱的可视化攻击范围
3. 添加陷阱冷却机制：地刺每次触发后短暂休眠

---

**下一章**：[第7章 兵种系统深度解析](第07章-兵种系统深度解析.md)
