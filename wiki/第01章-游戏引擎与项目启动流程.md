# 第1章 游戏引擎与项目启动流程

> **本章目标**：理解 Cocos2d-x 引擎的核心架构，掌握 VoidKings 项目的启动流程和初始化机制。

---

## 1.1 Cocos2d-x 引擎架构概述

### 1.1.1 Director 主循环机制详解

Cocos2d-x 的核心是 **Director（导演）** 单例，它负责管理整个游戏的生命周期。

```cpp
// 获取 Director 单例
auto director = Director::getInstance();
```

**主循环流程**：
1. **处理输入事件**：触摸、键盘、鼠标等
2. **更新逻辑**：调用所有节点的 `update(float dt)` 方法
3. **渲染场景**：遍历节点树进行绘制
4. **交换缓冲区**：显示渲染结果

```
┌─────────────────────────────────────────┐
│           Director 主循环               │
├─────────────────────────────────────────┤
│  1. 处理输入事件                        │
│       ↓                                 │
│  2. 调用 Scheduler 更新                 │
│       ↓                                 │
│  3. 遍历 Scene 节点树                   │
│       ↓                                 │
│  4. 调用 Renderer 渲染                  │
│       ↓                                 │
│  5. 交换 OpenGL 缓冲区                  │
│       ↓                                 │
│  6. 回到步骤 1（下一帧）                │
└─────────────────────────────────────────┘
```

**帧率控制**：
```cpp
// 设置每秒 60 帧
director->setAnimationInterval(1.0f / 60.0f);
```

### 1.1.2 Scene/Layer/Node 节点树结构

Cocos2d-x 采用**树形结构**组织所有游戏对象：

```
Scene (场景)
├── Layer (图层)
│   ├── Sprite (精灵)
│   ├── Label (文本)
│   └── Node (自定义节点)
│       ├── Sprite
│       └── ...
└── UILayer
    └── Button
```

**核心概念**：

| 类名 | 作用 | 示例 |
|------|------|------|
| `Node` | 所有可视对象的基类 | 自定义游戏对象 |
| `Scene` | 游戏场景容器 | 主菜单、战斗场景 |
| `Layer` | 逻辑分层（已弃用，推荐直接用Node） | UI层、游戏层 |
| `Sprite` | 2D图片显示 | 建筑、士兵 |
| `Label` | 文本显示 | 分数、提示 |

**节点坐标系统**：
- 原点在**左下角**
- X轴向右为正，Y轴向上为正
- 子节点坐标相对于父节点

```cpp
// 创建节点并添加到场景
auto sprite = Sprite::create("player.png");
sprite->setPosition(Vec2(100, 200));  // 相对于父节点
this->addChild(sprite, 1);  // zOrder=1 控制绘制顺序
```

### 1.1.3 渲染管线与 OpenGL 基础

Cocos2d-x 底层使用 **OpenGL ES** 进行渲染：

```
┌──────────────────────────────────────────────────────┐
│                    渲染流程                          │
├──────────────────────────────────────────────────────┤
│  Node::visit()                                       │
│      ↓                                               │
│  Node::draw() → 生成 RenderCommand                   │
│      ↓                                               │
│  Renderer::addCommand() → 加入渲染队列               │
│      ↓                                               │
│  Renderer::render() → 排序并执行 OpenGL 调用         │
│      ↓                                               │
│  OpenGL 绘制 → 输出到帧缓冲区                        │
└──────────────────────────────────────────────────────┘
```

**关键概念**：
- **Texture（纹理）**：图片加载到显存后的表示
- **Shader（着色器）**：控制渲染效果的程序
- **Batch（批次）**：合并多个绘制调用以提高性能

### 1.1.4 内存管理：引用计数与 autorelease 池

Cocos2d-x 使用**引用计数**管理内存：

```cpp
class Ref {
protected:
    unsigned int _referenceCount;  // 引用计数
public:
    void retain();   // 计数 +1
    void release();  // 计数 -1，归零时删除
    Ref* autorelease();  // 加入自动释放池
};
```

**autorelease 机制**：

```cpp
// 正确用法：create 方法内部调用 autorelease
Sprite* Sprite::create(const std::string& filename) {
    Sprite* sprite = new Sprite();
    if (sprite && sprite->initWithFile(filename)) {
        sprite->autorelease();  // 加入池，帧结束时自动 release
        return sprite;
    }
    CC_SAFE_DELETE(sprite);
    return nullptr;
}

// 使用时无需手动管理
auto sprite = Sprite::create("test.png");
this->addChild(sprite);  // addChild 内部会 retain
// 帧结束时 autorelease 池执行 release，但因为已被 addChild retain，不会被删除
```

**常见陷阱**：
```cpp
// 错误：create 后没有 addChild，对象会在帧结束时被释放
auto sprite = Sprite::create("test.png");
// ... 下一帧 sprite 已是悬空指针

// 正确：手动 retain
auto sprite = Sprite::create("test.png");
sprite->retain();  // 手动保持
// ... 使用完毕后
sprite->release();  // 手动释放
```

---

## 1.2 项目入口与初始化流程

### 1.2.1 AppDelegate.cpp 逐行解析

`AppDelegate` 是游戏的入口类，继承自 `Application`：

```cpp
// Classes/AppDelegate.cpp
#include "AppDelegate.h"
#include "Scenes/MainMenuScene.h"

USING_NS_CC;  // 等价于 using namespace cocos2d;

AppDelegate::AppDelegate() {}
AppDelegate::~AppDelegate() {}

// 应用启动时调用
bool AppDelegate::applicationDidFinishLaunching() {
    // 1. 获取 Director 单例
    auto director = Director::getInstance();
    
    // 2. 创建 OpenGL 视图（平台相关）
    auto glview = director->getOpenGLView();
    if (!glview) {
#if (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32)
        glview = GLViewImpl::createWithRect("VoidKings", 
            cocos2d::Rect(0, 0, 1280, 720));
#else
        glview = GLViewImpl::create("VoidKings");
#endif
        director->setOpenGLView(glview);
    }
    
    // 3. 设置设计分辨率
    glview->setDesignResolutionSize(1280, 720, 
        ResolutionPolicy::SHOW_ALL);
    
    // 4. 设置帧率
    director->setAnimationInterval(1.0f / 60.0f);
    
    // 5. 配置资源搜索路径
    auto fileUtils = FileUtils::getInstance();
    fileUtils->addSearchPath("Resources");
    
    // 6. 预加载资源到缓存
    auto cache = SpriteFrameCache::getInstance();
    for (int i = 1; i <= 10; ++i) {
        std::string frameName = StringUtils::format(
            "res/coin_spin_%d.png", i);
        auto texture = Director::getInstance()
            ->getTextureCache()->addImage(frameName);
        if (texture) {
            auto frame = SpriteFrame::createWithTexture(
                texture, 
                Rect(0, 0, texture->getContentSize().width,
                          texture->getContentSize().height));
            cache->addSpriteFrame(frame, frameName);
        }
    }
    
    // 7. 创建并运行首个场景
    auto scene = MainMenuScene::createScene();
    director->runWithScene(scene);
    
    return true;
}

// 应用进入后台
void AppDelegate::applicationDidEnterBackground() {
    Director::getInstance()->stopAnimation();
    // 可在此暂停音频
}

// 应用回到前台
void AppDelegate::applicationWillEnterForeground() {
    Director::getInstance()->startAnimation();
    // 可在此恢复音频
}
```

### 1.2.2 GLView 创建与分辨率适配策略

**设计分辨率** vs **屏幕分辨率**：

```cpp
// 设计分辨率：游戏内坐标系统使用的分辨率
glview->setDesignResolutionSize(1280, 720, policy);

// 分辨率策略
enum class ResolutionPolicy {
    EXACT_FIT,   // 拉伸填满，可能变形
    NO_BORDER,   // 填满屏幕，可能裁切
    SHOW_ALL,    // 完整显示，可能有黑边 ★推荐
    FIXED_HEIGHT,// 固定高度，宽度自适应
    FIXED_WIDTH  // 固定宽度，高度自适应
};
```

**VoidKings 采用 SHOW_ALL**：
- 保证所有内容可见
- 在宽屏设备上左右可能有黑边
- 在窄屏设备上上下可能有黑边

### 1.2.3 资源搜索路径配置原理

```cpp
auto fileUtils = FileUtils::getInstance();

// 添加搜索路径
fileUtils->addSearchPath("Resources");
fileUtils->addSearchPath("Resources/res");

// 加载资源时自动在这些路径下查找
auto sprite = Sprite::create("player.png");
// 实际查找顺序：
// 1. Resources/player.png
// 2. Resources/res/player.png
```

**完整路径获取**：
```cpp
std::string fullPath = fileUtils->fullPathForFilename("config.json");
// 返回类似 "D:/Game/Resources/config.json"
```

### 1.2.4 首场景加载与帧率设置

```cpp
// 运行首个场景
director->runWithScene(MainMenuScene::createScene());

// 之后切换场景使用 replaceScene
director->replaceScene(TransitionFade::create(0.5f, newScene));

// 帧率设置
director->setAnimationInterval(1.0f / 60.0f);  // 60 FPS
director->setAnimationInterval(1.0f / 30.0f);  // 30 FPS（省电模式）
```

---

## 1.3 项目目录结构详解

### 1.3.1 Classes 业务代码组织

```
Classes/
├── AppDelegate.cpp/h        # 应用入口
├── Buildings/               # 建筑系统
│   ├── BuildingManager.*    # 建筑管理器（单例）
│   ├── BuildingCatalog.h    # 建筑配置结构体
│   ├── DefenceBuilding.*    # 防御建筑
│   ├── ProductionBuilding.* # 生产建筑
│   ├── StorageBuilding.*    # 仓库建筑
│   └── Trap.*               # 陷阱
├── Bullet/                  # 子弹系统
│   └── Bullet.*
├── Core/                    # 核心数据
│   └── Core.*               # 资源、等级管理（单例）
├── Map/                     # 地图系统
│   └── GridMap.*            # 网格地图
├── Replay/                  # 回放系统
│   └── ReplayManager.*
├── Save/                    # 存档系统
│   └── SaveManager.*
├── Scenes/                  # 场景
│   ├── MainMenuScene.*      # 主菜单
│   ├── BaseScene.*          # 基地场景
│   ├── BattleScene.*        # 战斗场景
│   └── components/          # 场景组件
│       └── PlacementManager.*
├── Share/                   # 异步攻防
│   └── BattleShareManager.*
├── Soldier/                 # 士兵系统
│   ├── Soldier.*            # 士兵基类
│   ├── UnitData.h           # 兵种配置结构体
│   └── UnitManager.*        # 兵种管理器（单例）
├── UI/                      # UI 组件
│   ├── TrainPanel.*         # 训练面板
│   └── ...
└── Utils/                   # 工具类
    ├── AnimationUtils.*     # 动画工具
    ├── AudioManager.*       # 音频管理
    ├── EffectUtils.*        # 特效工具
    └── GameSettings.*       # 游戏设置
```

### 1.3.2 Resources 资源文件规范

```
Resources/
├── res/                     # 配置与 UI 资源
│   ├── buildings_config.json   # 建筑配置
│   ├── units_config.json       # 兵种配置
│   ├── coin_spin_*.png         # 金币动画帧
│   └── health_bar.png
├── buildings/               # 建筑贴图
│   ├── ArrowTower/
│   ├── BoomTower/
│   └── ...
├── unit/                    # 兵种贴图
│   ├── MiniSpearMan_output/
│   │   ├── spearman_idle_1.png
│   │   ├── spearman_walk_1.png
│   │   └── ...
│   └── ...
├── UI/                      # UI 贴图
│   ├── exit.png
│   ├── retry.png
│   └── ...
├── fonts/                   # 字体
│   └── ScienceGothic.ttf
├── music/                   # 背景音乐
│   └── bgm_*.mp3
└── source/                  # 音效
    └── *.wav
```

### 1.3.3 平台工程结构

**Windows (proj.win32/)**：
```
proj.win32/
├── VoidKings.sln           # Visual Studio 解决方案
├── VoidKings.vcxproj       # 项目文件
└── main.cpp                # Windows 入口
```

**Android (proj.android/)**：
```
proj.android/
├── app/
│   ├── src/main/
│   │   ├── java/.../AppActivity.java  # Android 入口
│   │   └── jni/                       # NDK 配置
│   └── build.gradle
├── build.gradle
├── settings.gradle
└── gradlew                  # Gradle 包装器
```

---

## 本章小结

1. **Director** 是游戏的总控，负责主循环和场景管理
2. **节点树** 结构组织所有游戏对象，父子关系影响坐标和渲染
3. **autorelease** 机制简化内存管理，但需理解其工作原理
4. **AppDelegate** 是游戏入口，负责初始化和资源预加载
5. 项目代码按**功能模块**组织，资源按**类型**分目录

---

## 练习题

1. 在 `AppDelegate::applicationDidFinishLaunching()` 中添加日志输出，观察启动顺序
2. 尝试修改设计分辨率为 800×600，观察显示效果变化
3. 找到 `MainMenuScene::createScene()` 的实现，理解场景创建流程

---

**下一章**：[第2章 C++ 设计模式在游戏中的应用](第02章-C++设计模式在游戏中的应用.md)
