# 第2章 C++ 设计模式在游戏中的应用

> **本章目标**：理解 VoidKings 项目中使用的核心设计模式，学会在游戏开发中正确应用这些模式。

---

## 2.1 单例模式实现与陷阱

### 2.1.1 Core::getInstance() 实现分析

**单例模式**确保一个类只有一个实例，并提供全局访问点。

VoidKings 中的 `Core` 类是典型的单例：

```cpp
// Classes/Core/Core.h
class Core {
public:
    static Core* getInstance();  // 获取单例
    
    // 禁止拷贝和赋值
    Core(const Core&) = delete;
    Core& operator=(const Core&) = delete;
    
private:
    Core();   // 私有构造函数
    ~Core();
    
    static Core* _instance;  // 静态实例指针
};

// Classes/Core/Core.cpp
Core* Core::_instance = nullptr;

Core* Core::getInstance() {
    if (!_instance) {
        _instance = new Core();
    }
    return _instance;
}
```

**为什么要用单例？**
- 游戏资源（金币、钻石）全局唯一
- 避免多个实例导致数据不一致
- 方便任何地方访问

**使用示例**：
```cpp
// 任何地方都可以访问
int coins = Core::getInstance()->getResource(ResourceType::COIN);
Core::getInstance()->addResource(ResourceType::COIN, 100);
```

### 2.1.2 线程安全与内存泄漏防范

**问题1：线程安全**

上述简单实现在多线程环境下可能创建多个实例：

```cpp
// 不安全：两个线程可能同时判断 _instance == nullptr
Core* Core::getInstance() {
    if (!_instance) {           // 线程A和B同时到达这里
        _instance = new Core(); // 可能创建两个实例！
    }
    return _instance;
}
```

**解决方案（C++11）**：
```cpp
Core* Core::getInstance() {
    static Core instance;  // 局部静态变量，C++11 保证线程安全
    return &instance;
}
```

**问题2：内存泄漏**

使用 `new` 创建的单例需要在合适时机释放：

```cpp
// 方案1：提供销毁方法
void Core::destroyInstance() {
    delete _instance;
    _instance = nullptr;
}

// 方案2：使用 atexit 注册清理函数
Core* Core::getInstance() {
    if (!_instance) {
        _instance = new Core();
        std::atexit([]() {
            delete _instance;
        });
    }
    return _instance;
}
```

### 2.1.3 单例生命周期管理：retain()/release()

在 Cocos2d-x 中，如果单例需要作为 Node 使用（如 UI 管理器），需要注意引用计数：

```cpp
// 继承自 Node 的单例
class UIManager : public Node {
public:
    static UIManager* getInstance() {
        if (!_instance) {
            _instance = new UIManager();
            _instance->init();
            _instance->retain();  // 防止被 autorelease 池释放
        }
        return _instance;
    }
    
    static void destroyInstance() {
        if (_instance) {
            _instance->release();
            _instance = nullptr;
        }
    }
};
```

---

## 2.2 工厂模式：建筑与兵种创建

### 2.2.1 BuildingManager::createDefenceBuilding() 源码解析

**工厂模式**将对象的创建逻辑封装起来，调用方无需关心具体实现细节。

```cpp
// Classes/Buildings/BuildingManager.cpp

DefenceBuilding* BuildingManager::createDefenceBuilding(int configId, int level) {
    // 1. 查找配置
    const DefenceConfig* config = getDefenceConfig(configId);
    if (!config) {
        CCLOG("BuildingManager: Defence config not found: %d", configId);
        return nullptr;
    }
    
    // 2. 创建建筑实例
    auto building = DefenceBuilding::create(config, level);
    if (!building) {
        CCLOG("BuildingManager: Failed to create DefenceBuilding");
        return nullptr;
    }
    
    // 3. 返回配置好的建筑
    return building;
}
```

**工厂模式的好处**：
1. **解耦**：调用方只需知道 configId，不需要知道具体创建过程
2. **集中管理**：所有建筑的创建逻辑在一处
3. **易于扩展**：添加新建筑类型只需修改工厂

### 2.2.2 配置驱动的对象生成

VoidKings 使用 JSON 配置驱动对象创建：

```json
// Resources/res/buildings_config.json
{
  "defenceBuildings": [
    {
      "id": 1001,
      "name": "ArrowTower",
      "HP": [100, 120, 150, 180, 220],
      "ATK": [15, 20, 25, 32, 40],
      "ATK_SPEED": [1.0, 0.95, 0.9, 0.85, 0.8],
      "ATK_RANGE": [150, 160, 170, 180, 200],
      "width": 3,
      "length": 3,
      "MAXLEVEL": 4
    }
  ]
}
```

**工厂根据配置创建对象**：
```cpp
// 加载配置
bool BuildingManager::loadConfigs() {
    std::string jsonData = FileUtils::getInstance()
        ->getStringFromFile("res/buildings_config.json");
    
    rapidjson::Document doc;
    doc.Parse(jsonData.c_str());
    
    // 解析防御建筑配置
    if (doc.HasMember("defenceBuildings")) {
        for (auto& item : doc["defenceBuildings"].GetArray()) {
            DefenceConfig config;
            config.id = item["id"].GetInt();
            config.name = item["name"].GetString();
            // ... 解析其他字段
            _defenceConfigs[config.id] = config;
        }
    }
    return true;
}
```

### 2.2.3 工厂方法 vs 抽象工厂

**工厂方法**：一个方法创建一类对象
```cpp
class BuildingManager {
    DefenceBuilding* createDefenceBuilding(int id, int level);
    ProductionBuilding* createProductionBuilding(int id, int level);
    StorageBuilding* createStorageBuilding(int id, int level);
};
```

**抽象工厂**：一个工厂创建一系列相关对象
```cpp
// 假设有不同风格的建筑
class BuildingFactory {
public:
    virtual DefenceBuilding* createDefence() = 0;
    virtual ProductionBuilding* createProduction() = 0;
};

class HumanBuildingFactory : public BuildingFactory {
    DefenceBuilding* createDefence() override { /* 人类风格 */ }
};

class OrcBuildingFactory : public BuildingFactory {
    DefenceBuilding* createDefence() override { /* 兽人风格 */ }
};
```

VoidKings 当前使用**简单工厂/工厂方法**，如需支持多阵营可扩展为抽象工厂。

---

## 2.3 观察者模式与事件系统

### 2.3.1 Cocos2d-x EventDispatcher 机制

**观察者模式**实现对象间松耦合的通信。

Cocos2d-x 提供了强大的事件系统：

```cpp
// 获取事件分发器
auto dispatcher = Director::getInstance()->getEventDispatcher();
// 或者
auto dispatcher = _eventDispatcher;  // Node 成员变量
```

**事件类型**：
- `EventListenerTouchOneByOne`：单点触摸
- `EventListenerTouchAllAtOnce`：多点触摸
- `EventListenerMouse`：鼠标事件
- `EventListenerKeyboard`：键盘事件
- `EventListenerCustom`：自定义事件

### 2.3.2 触摸事件监听实现

VoidKings 中的触摸处理示例：

```cpp
// BattleScene.cpp
void BattleScene::initTouchListener() {
    auto listener = EventListenerTouchOneByOne::create();
    
    // 设置是否吞噬事件（阻止传递给下层）
    listener->setSwallowTouches(true);
    
    // 触摸开始
    listener->onTouchBegan = [this](Touch* touch, Event* event) -> bool {
        Vec2 touchPos = touch->getLocation();
        
        // 检查是否在有效区域
        if (touchPos.y < UI_BOTTOM_HEIGHT) {
            return false;  // 不处理，事件继续传递
        }
        
        // 处理部署逻辑
        this->deploySoldier(_selectedUnitId, touchPos);
        return true;  // 已处理，吞噬事件
    };
    
    // 触摸移动
    listener->onTouchMoved = [this](Touch* touch, Event* event) {
        // 处理拖拽逻辑
    };
    
    // 触摸结束
    listener->onTouchEnded = [this](Touch* touch, Event* event) {
        // 处理释放逻辑
    };
    
    // 注册监听器
    _eventDispatcher->addEventListenerWithSceneGraphPriority(
        listener, this);
}
```

**关键概念**：
- `onTouchBegan` 返回 `true` 表示接收后续事件
- `setSwallowTouches(true)` 阻止事件向下传递
- 场景销毁时监听器自动移除

### 2.3.3 自定义游戏事件传递

用于模块间通信而不直接依赖：

```cpp
// 定义事件名称
#define EVENT_RESOURCE_CHANGED "event_resource_changed"

// 发送事件
void Core::addResource(ResourceType type, int amount) {
    _resources[type] += amount;
    
    // 发送事件通知 UI 更新
    EventCustom event(EVENT_RESOURCE_CHANGED);
    event.setUserData(&type);
    Director::getInstance()->getEventDispatcher()->dispatchEvent(&event);
}

// 监听事件
void BaseUIPanel::init() {
    auto listener = EventListenerCustom::create(
        EVENT_RESOURCE_CHANGED,
        [this](EventCustom* event) {
            this->updateResourceDisplay();
        }
    );
    _eventDispatcher->addEventListenerWithSceneGraphPriority(
        listener, this);
}
```

---

## 2.4 享元模式：配置数据复用

### 2.4.1 UnitConfig 指针引用设计

**享元模式**通过共享来减少对象数量，节省内存。

VoidKings 中的配置数据共享：

```cpp
// Classes/Soldier/UnitData.h
struct UnitConfig {
    int id;
    std::string name;
    std::vector<float> HP;      // 各等级血量
    std::vector<float> ATK;     // 各等级攻击力
    std::vector<float> SPEED;   // 各等级移动速度
    // ... 其他配置
};

// Classes/Soldier/Soldier.h
class Soldier : public Node {
private:
    // 配置模板——一个指针引用（享元模式）
    // 所有同类型士兵共享同一份配置，不需要每个实例保存一份
    const UnitConfig* _config;
    
    // 运行时数据——每个实例独有
    int _level;
    float _currentHP;
    float _attackTimer;
};
```

**好处**：
- 100 个枪兵只需 1 份 `UnitConfig`
- 修改配置自动影响所有实例
- 节省大量内存

**注意事项**：
- 配置数据应为只读
- 配置生命周期必须长于使用者

### 2.4.2 动画缓存与纹理复用

Cocos2d-x 内置了多种缓存机制：

```cpp
// 纹理缓存
auto textureCache = Director::getInstance()->getTextureCache();
auto texture = textureCache->addImage("player.png");
// 同一图片多次加载，实际只有一份纹理

// 精灵帧缓存
auto frameCache = SpriteFrameCache::getInstance();
frameCache->addSpriteFramesWithFile("sprites.plist");
auto frame = frameCache->getSpriteFrameByName("hero_idle_1.png");

// 动画缓存
auto animCache = AnimationCache::getInstance();
animCache->addAnimation(animation, "hero_walk");
auto anim = animCache->getAnimation("hero_walk");
```

**AnimationUtils 中的享元实现**：
```cpp
Animation* AnimationUtils::buildAnimationFromFrames(
    const std::string& baseName,
    const std::string& animKey,
    int frameCount,
    float delay,
    bool useCache)  // 是否使用缓存
{
    std::string cacheKey = baseName + "_" + animKey;
    
    // 检查缓存
    if (useCache) {
        auto cached = AnimationCache::getInstance()->getAnimation(cacheKey);
        if (cached) return cached;  // 命中缓存，直接返回
    }
    
    // 创建新动画
    Vector<SpriteFrame*> frames;
    for (int i = 1; i <= frameCount; ++i) {
        // 加载帧...
    }
    
    auto anim = Animation::createWithSpriteFrames(frames, delay);
    
    // 存入缓存
    if (useCache) {
        AnimationCache::getInstance()->addAnimation(anim, cacheKey);
    }
    
    return anim;
}
```

---

## 其他设计模式简介

### 状态模式（State）

用于管理对象的状态转换，如士兵的 AI 状态：

```cpp
// 简化版状态机（VoidKings 当前使用 if-else 实现）
enum class SoldierState {
    IDLE,
    MOVING,
    ATTACKING,
    DEAD
};

class Soldier {
    SoldierState _state;
    
    void update(float dt) {
        switch (_state) {
            case SoldierState::IDLE:
                findTarget();
                break;
            case SoldierState::MOVING:
                moveToTarget(dt);
                break;
            case SoldierState::ATTACKING:
                attackTarget();
                break;
            case SoldierState::DEAD:
                // 播放死亡动画
                break;
        }
    }
};
```

### 命令模式（Command）

用于回放系统，记录玩家操作：

```cpp
// ReplayDeployEvent 就是一个命令对象
struct ReplayDeployEvent {
    float time;   // 执行时间
    int unitId;   // 部署的兵种
    int gridX;    // 位置 X
    int gridY;    // 位置 Y
    int level;    // 等级
};

// 回放时按时间顺序执行命令
void BattleScene::updateReplayPlayback() {
    while (_replayEventIndex < _replayData.events.size()) {
        const auto& event = _replayData.events[_replayEventIndex];
        if (_battleTime < event.time) break;
        
        // 执行命令
        deployReplaySoldier(event);
        _replayEventIndex++;
    }
}
```

---

## 本章小结

| 设计模式 | 在 VoidKings 中的应用 | 好处 |
|----------|----------------------|------|
| 单例 | Core、BuildingManager、UnitManager | 全局唯一访问点 |
| 工厂 | createDefenceBuilding() | 解耦创建逻辑 |
| 观察者 | EventDispatcher、触摸监听 | 松耦合通信 |
| 享元 | UnitConfig 共享、动画缓存 | 节省内存 |
| 状态 | 士兵 AI 状态管理 | 清晰的状态转换 |
| 命令 | 回放事件记录 | 操作可序列化 |

---

## 练习题

1. 在 `Core` 类中添加一个新的资源类型（如"圣水"），并在 UI 中显示
2. 为 `UnitManager` 添加日志，追踪单例的创建时机
3. 尝试用自定义事件实现"建筑建造完成"的通知

---

**下一章**：[第3章 网格建造系统深度剖析](第03章-网格建造系统深度剖析.md)
