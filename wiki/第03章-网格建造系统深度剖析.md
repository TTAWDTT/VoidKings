# 第3章 网格建造系统深度剖析

> **本章目标**：深入理解 VoidKings 的网格地图实现，掌握建筑放置检测、坐标转换、交互反馈等核心机制。

---

## 3.1 GridMap 网格地图底层实现

### 3.1.1 二维向量存储格子状态

`GridMap` 是建造系统的基础，管理所有格子的状态：

```cpp
// Classes/Map/GridMap.h
class GridMap : public Node {
public:
    static GridMap* create(int width, int height, float cellSize);
    
private:
    int _gridWidth;                  // 网格宽度（格子数）
    int _gridHeight;                 // 网格高度（格子数）
    float _cellSize;                 // 每格像素大小
    
    // 格子状态：_cells[y][x]
    std::vector<std::vector<CellType>> _cells;
    
    // 格子上的建筑：_buildings[y][x]
    std::vector<std::vector<Node*>> _buildings;
};
```

**初始化过程**：
```cpp
bool GridMap::init(int width, int height, float cellSize) {
    if (!Node::init()) return false;
    
    _gridWidth = width;
    _gridHeight = height;
    _cellSize = cellSize;
    
    // 初始化二维向量
    _cells.resize(height);
    _buildings.resize(height);
    for (int y = 0; y < height; ++y) {
        _cells[y].resize(width, CellType::EMPTY);
        _buildings[y].resize(width, nullptr);
    }
    
    return true;
}
```

### 3.1.2 格子状态枚举设计

```cpp
enum class CellType {
    EMPTY,      // 空地，可放置建筑
    OCCUPIED,   // 已被建筑占用
    FORBIDDEN   // 禁止放置（边界、装饰等）
};
```

**为什么需要 FORBIDDEN？**
- 地图边缘留白
- 预留特殊区域（如出生点）
- 装饰物占位

```cpp
// 初始化边界禁区
void GridMap::initBorderForbidden(int borderWidth) {
    for (int y = 0; y < _gridHeight; ++y) {
        for (int x = 0; x < _gridWidth; ++x) {
            if (x < borderWidth || x >= _gridWidth - borderWidth ||
                y < borderWidth || y >= _gridHeight - borderWidth) {
                _cells[y][x] = CellType::FORBIDDEN;
            }
        }
    }
}
```

### 3.1.3 坐标转换算法详解

游戏中需要在**格子坐标**和**世界坐标**之间转换：

```
世界坐标 (像素)
┌─────────────────────────────────────┐
│                                     │
│    ┌───┬───┬───┬───┐               │
│    │0,2│1,2│2,2│3,2│  格子坐标     │
│    ├───┼───┼───┼───┤               │
│    │0,1│1,1│2,1│3,1│               │
│    ├───┼───┼───┼───┤               │
│    │0,0│1,0│2,0│3,0│               │
│    └───┴───┴───┴───┘               │
│  (0,0)                              │
└─────────────────────────────────────┘
```

```cpp
// 格子坐标 → 世界坐标（格子中心点）
Vec2 GridMap::gridToWorld(int gridX, int gridY) const {
    float worldX = gridX * _cellSize + _cellSize * 0.5f;
    float worldY = gridY * _cellSize + _cellSize * 0.5f;
    return Vec2(worldX, worldY);
}

// 重载：直接传入 Vec2
Vec2 GridMap::gridToWorld(const Vec2& gridPos) const {
    return gridToWorld(
        static_cast<int>(gridPos.x), 
        static_cast<int>(gridPos.y)
    );
}

// 世界坐标 → 格子坐标
Vec2 GridMap::worldToGrid(const Vec2& worldPos) const {
    int gridX = static_cast<int>(worldPos.x / _cellSize);
    int gridY = static_cast<int>(worldPos.y / _cellSize);
    
    // 边界检查
    gridX = std::max(0, std::min(gridX, _gridWidth - 1));
    gridY = std::max(0, std::min(gridY, _gridHeight - 1));
    
    return Vec2(gridX, gridY);
}
```

**示例**：
```cpp
// 假设 _cellSize = 32

// 格子 (5, 3) 的世界坐标中心
Vec2 worldPos = gridMap->gridToWorld(5, 3);
// worldPos = (5*32 + 16, 3*32 + 16) = (176, 112)

// 世界坐标 (100, 80) 对应的格子
Vec2 gridPos = gridMap->worldToGrid(Vec2(100, 80));
// gridPos = (100/32, 80/32) = (3, 2)
```

### 3.1.4 边界禁区初始化逻辑

```cpp
void GridMap::initWithBorder() {
    // 外围 2 格设为禁区
    for (int y = 0; y < _gridHeight; ++y) {
        for (int x = 0; x < _gridWidth; ++x) {
            if (x < 2 || x >= _gridWidth - 2 ||
                y < 2 || y >= _gridHeight - 2) {
                _cells[y][x] = CellType::FORBIDDEN;
            }
        }
    }
}
```

---

## 3.2 建筑放置检测算法

### 3.2.1 canPlaceBuilding() 遍历策略

放置建筑前必须检测目标区域是否全部为空：

```cpp
bool GridMap::canPlaceBuilding(int startX, int startY, 
                                int width, int height) const {
    // 1. 边界检查
    if (startX < 0 || startY < 0 ||
        startX + width > _gridWidth ||
        startY + height > _gridHeight) {
        return false;
    }
    
    // 2. 遍历检查每个格子
    for (int y = startY; y < startY + height; ++y) {
        for (int x = startX; x < startX + width; ++x) {
            if (_cells[y][x] != CellType::EMPTY) {
                return false;  // 有任何一格不为空就失败
            }
        }
    }
    
    return true;
}
```

**时间复杂度**：O(width × height)，对于小建筑（3×3）可忽略不计。

### 3.2.2 行优先索引 _cells[y][x] 的坑

**常见错误**：
```cpp
// 错误！混淆 x 和 y
_cells[x][y]  // ❌ 会导致越界或数据错乱

// 正确：先行后列
_cells[y][x]  // ✓ 与数学坐标系一致
```

**为什么用 [y][x] 而不是 [x][y]？**
- 二维数组在内存中按行存储
- `_cells[y]` 先定位到第 y 行
- `_cells[y][x]` 再在该行中取第 x 个元素

**助记方法**：想象表格，先选行（y），再选列（x）。

### 3.2.3 多格建筑占用标记

放置成功后，需要标记所有占用的格子：

```cpp
void GridMap::occupyCell(int startX, int startY, 
                         int width, int height, Node* building) {
    for (int y = startY; y < startY + height; ++y) {
        for (int x = startX; x < startX + width; ++x) {
            _cells[y][x] = CellType::OCCUPIED;
            _buildings[y][x] = building;  // 记录建筑指针
        }
    }
}
```

**示例**：放置 3×3 的箭塔在 (5, 5)
```
放置前:               放置后:
. . . . . . . .      . . . . . . . .
. . . . . . . .      . . . . . . . .
. . . . . . . .      . . . . . ■ ■ ■
. . . . . . . .      . . . . . ■ ■ ■
. . . . . . . .      . . . . . ■ ■ ■
. . . . . . . .      . . . . . . . .

■ 表示 OCCUPIED，存储指向同一个 building 的指针
```

### 3.2.4 建筑移除与格子释放

拆除建筑时需要释放占用的格子：

```cpp
void GridMap::freeCell(int startX, int startY, 
                       int width, int height) {
    for (int y = startY; y < startY + height; ++y) {
        for (int x = startX; x < startX + width; ++x) {
            // 边界检查
            if (x >= 0 && x < _gridWidth && 
                y >= 0 && y < _gridHeight) {
                _cells[y][x] = CellType::EMPTY;
                _buildings[y][x] = nullptr;
            }
        }
    }
}
```

---

## 3.3 PlacementManager 交互层实现

### 3.3.1 建筑预览 Sprite 创建

玩家选择建筑后，创建半透明预览：

```cpp
void PlacementManager::startPlacement(const BuildingOption& option) {
    _currentOption = option;
    _isPlacing = true;
    
    // 创建预览精灵
    _previewSprite = Sprite::create(option.spritePath);
    if (_previewSprite) {
        _previewSprite->setOpacity(180);  // 半透明
        _gridMap->addChild(_previewSprite, 100);
    }
    
    // 创建格子高亮层
    _highlightNode = DrawNode::create();
    _gridMap->addChild(_highlightNode, 99);
}
```

### 3.3.2 触摸移动实时更新位置

```cpp
void PlacementManager::onTouchMoved(Touch* touch, Event* event) {
    if (!_isPlacing) return;
    
    // 1. 获取触摸点在地图上的位置
    Vec2 touchPos = touch->getLocation();
    Vec2 localPos = _gridMap->convertToNodeSpace(touchPos);
    
    // 2. 转换为格子坐标
    Vec2 gridPos = _gridMap->worldToGrid(localPos);
    _currentGridX = static_cast<int>(gridPos.x);
    _currentGridY = static_cast<int>(gridPos.y);
    
    // 3. 更新预览位置（对齐到格子中心）
    updatePreviewPosition();
    
    // 4. 更新格子高亮
    updateHighlight();
}

void PlacementManager::updatePreviewPosition() {
    if (!_previewSprite) return;
    
    int width = _currentOption.gridWidth;
    int height = _currentOption.gridHeight;
    
    // 计算建筑中心的世界坐标
    float centerX = (_currentGridX + width * 0.5f) * _cellSize;
    float centerY = (_currentGridY + height * 0.5f) * _cellSize;
    
    _previewSprite->setPosition(Vec2(centerX, centerY));
}
```

### 3.3.3 红/绿色格子高亮渲染

根据是否可放置显示不同颜色：

```cpp
void PlacementManager::updateHighlight() {
    if (!_highlightNode) return;
    _highlightNode->clear();
    
    int width = _currentOption.gridWidth;
    int height = _currentOption.gridHeight;
    
    // 检查是否可放置
    bool canPlace = _gridMap->canPlaceBuilding(
        _currentGridX, _currentGridY, width, height);
    
    // 选择颜色
    Color4F color = canPlace 
        ? Color4F(0, 1, 0, 0.3f)    // 绿色半透明
        : Color4F(1, 0, 0, 0.3f);   // 红色半透明
    
    // 绘制高亮区域
    for (int dy = 0; dy < height; ++dy) {
        for (int dx = 0; dx < width; ++dx) {
            int gx = _currentGridX + dx;
            int gy = _currentGridY + dy;
            
            Vec2 bl(gx * _cellSize, gy * _cellSize);           // 左下角
            Vec2 tr((gx + 1) * _cellSize, (gy + 1) * _cellSize); // 右上角
            
            _highlightNode->drawSolidRect(bl, tr, color);
        }
    }
}
```

### 3.3.4 确认放置与回调通知

```cpp
bool PlacementManager::tryConfirmPlacement() {
    if (!_isPlacing) return false;
    
    int width = _currentOption.gridWidth;
    int height = _currentOption.gridHeight;
    
    // 再次检查是否可放置
    if (!_gridMap->canPlaceBuilding(
        _currentGridX, _currentGridY, width, height)) {
        // 播放错误音效
        AudioManager::playButtonCancel();
        return false;
    }
    
    // 通知场景确认放置
    if (_onPlacementConfirmed) {
        _onPlacementConfirmed(_currentOption, 
                              _currentGridX, _currentGridY);
    }
    
    // 清理预览
    endPlacement();
    
    return true;
}

void PlacementManager::endPlacement() {
    _isPlacing = false;
    
    if (_previewSprite) {
        _previewSprite->removeFromParent();
        _previewSprite = nullptr;
    }
    
    if (_highlightNode) {
        _highlightNode->removeFromParent();
        _highlightNode = nullptr;
    }
}
```

---

## 3.4 建筑缩放与对齐

### 3.4.1 scaleBuildingToFit() 源码分析

建筑贴图尺寸各异，需要统一缩放以适应格子：

```cpp
void BattleScene::scaleBuildingToFit(Node* building, 
                                      int gridWidth, 
                                      int gridHeight, 
                                      float cellSize) {
    if (!building) return;
    
    // 查找建筑的主精灵
    auto sprite = NodeUtils::findBodySprite(building);
    if (!sprite) return;
    
    // 1. 计算目标尺寸（留点边距）
    constexpr float PADDING_FACTOR = 0.85f;
    float targetWidth = gridWidth * cellSize * PADDING_FACTOR;
    float targetHeight = gridHeight * cellSize * PADDING_FACTOR;
    
    // 2. 获取原始尺寸
    Size originalSize = sprite->getContentSize();
    if (originalSize.width <= 0 || originalSize.height <= 0) return;
    
    // 3. 计算缩放比例（保持宽高比）
    float scaleX = targetWidth / originalSize.width;
    float scaleY = targetHeight / originalSize.height;
    float scale = std::min(scaleX, scaleY);  // 取较小值，确保不超出
    
    // 4. 应用缩放
    sprite->setScale(scale);
}
```

### 3.4.2 锚点与中心点定位

Cocos2d-x 中锚点决定了节点的定位参考点：

```cpp
// 默认锚点 (0.5, 0.5) 表示中心
sprite->setAnchorPoint(Vec2(0.5f, 0.5f));

// 此时 setPosition 设置的是中心点位置
sprite->setPosition(Vec2(100, 100));  // 中心在 (100, 100)
```

**建筑定位流程**：
```cpp
// 1. 计算建筑占用区域的中心世界坐标
float centerX = (gridX + gridWidth * 0.5f) * cellSize;
float centerY = (gridY + gridHeight * 0.5f) * cellSize;

// 2. 建筑使用默认锚点 (0.5, 0.5)
building->setPosition(Vec2(centerX, centerY));

// 效果：建筑中心与占用格子的中心重合
```

### 3.4.3 不同尺寸建筑的处理

| 建筑类型 | 占地 | 缩放策略 |
|---------|------|----------|
| 箭塔 | 3×3 | 标准缩放 |
| 炮塔 | 3×3 | 标准缩放 |
| 主基地 | 4×4 | 略大 |
| 兵营 | 5×5 | 略大 |
| 陷阱 | 1×1 | 较小 |

```cpp
// 根据配置动态处理
void BaseScene::placeBuilding(const BuildingOption& option, 
                               int gridX, int gridY) {
    // 创建建筑
    Node* building = createBuildingFromOption(option, 0);
    
    // 缩放适配
    scaleBuildingToFit(building, 
                       option.gridWidth, 
                       option.gridHeight,
                       _gridMap->getCellSize());
    
    // 定位
    float centerX = (gridX + option.gridWidth * 0.5f) * _cellSize;
    float centerY = (gridY + option.gridHeight * 0.5f) * _cellSize;
    building->setPosition(Vec2(centerX, centerY));
    
    // 加入场景
    _buildingLayer->addChild(building);
    
    // 标记格子占用
    _gridMap->occupyCell(gridX, gridY, 
                         option.gridWidth, option.gridHeight, 
                         building);
}
```

---

## 网格调试技巧

### 显示网格线

```cpp
void GridMap::showGrid(bool show) {
    if (!_gridLineNode) {
        _gridLineNode = DrawNode::create();
        this->addChild(_gridLineNode, 1000);
    }
    
    _gridLineNode->clear();
    _gridLineNode->setVisible(show);
    
    if (!show) return;
    
    Color4F lineColor(0.5f, 0.5f, 0.5f, 0.3f);
    
    // 绘制垂直线
    for (int x = 0; x <= _gridWidth; ++x) {
        float px = x * _cellSize;
        _gridLineNode->drawLine(
            Vec2(px, 0), 
            Vec2(px, _gridHeight * _cellSize), 
            lineColor);
    }
    
    // 绘制水平线
    for (int y = 0; y <= _gridHeight; ++y) {
        float py = y * _cellSize;
        _gridLineNode->drawLine(
            Vec2(0, py), 
            Vec2(_gridWidth * _cellSize, py), 
            lineColor);
    }
}
```

---

## 本章小结

1. **GridMap** 使用二维向量存储格子状态，注意 `[y][x]` 索引顺序
2. **坐标转换** 是网格系统的核心，`gridToWorld` 和 `worldToGrid` 相互对应
3. **放置检测** 需要遍历目标区域的每个格子
4. **PlacementManager** 负责交互层逻辑：预览、高亮、确认
5. **建筑缩放** 保持宽高比，使用锚点居中定位

---

## 练习题

1. 修改边界禁区宽度为 3，观察建造范围变化
2. 在 `canPlaceBuilding()` 中添加日志，输出检测过程
3. 尝试实现建筑移动功能：拆除后重新放置

---

**下一章**：[第4章 资源管理与经济系统](第04章-资源管理与经济系统.md)
