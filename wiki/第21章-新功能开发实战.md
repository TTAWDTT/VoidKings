# 第21章 新功能开发实战

> **本章目标**：通过实际案例学习如何在 VoidKings 中添加新功能。

---

## 21.1 添加新建筑类型

### 21.1.1 JSON 配置添加

在 `Resources/res/buildings_config.json` 中添加：

```json
{
  "defenceBuildings": [
    // ... 现有建筑 ...
    {
      "id": 1006,
      "name": "IceTower",
      "HP": [80, 100, 120, 150, 180],
      "ATK": [5, 7, 10, 12, 15],
      "ATK_SPEED": [1.5, 1.4, 1.3, 1.2, 1.1],
      "ATK_RANGE": [120, 130, 140, 150, 160],
      "width": 2,
      "length": 2,
      "MAXLEVEL": 4,
      "GROUND_ABLE": true,
      "SKY_ABLE": false,
      "spritePath": "buildings/IceTower/ice_tower.png",
      "bulletSprite": "buildings/IceTower/ice_bolt.png",
      "bulletSpeed": 250,
      "slowEffect": true,
      "slowDuration": 2.0,
      "slowPercent": 0.5
    }
  ]
}
```

### 21.1.2 新建筑类创建

```cpp
// Classes/Buildings/IceTower.h
#ifndef __ICE_TOWER_H__
#define __ICE_TOWER_H__

#include "DefenceBuilding.h"

class IceTower : public DefenceBuilding {
public:
    static IceTower* create(const DefenceConfig* config, int level);
    bool init(const DefenceConfig* config, int level) override;
    
protected:
    void onHitTarget(Soldier* target) override;
    
private:
    float _slowDuration;
    float _slowPercent;
};

#endif
```

```cpp
// Classes/Buildings/IceTower.cpp
#include "IceTower.h"
#include "Soldier/Soldier.h"

IceTower* IceTower::create(const DefenceConfig* config, int level) {
    IceTower* ret = new (std::nothrow) IceTower();
    if (ret && ret->init(config, level)) {
        ret->autorelease();
        return ret;
    }
    CC_SAFE_DELETE(ret);
    return nullptr;
}

bool IceTower::init(const DefenceConfig* config, int level) {
    if (!DefenceBuilding::init(config, level)) {
        return false;
    }
    
    _slowDuration = 2.0f;  // 可从配置读取
    _slowPercent = 0.5f;
    
    return true;
}

void IceTower::onHitTarget(Soldier* target) {
    DefenceBuilding::onHitTarget(target);
    
    if (target && !target->isDead()) {
        // 应用减速效果
        target->applySlow(_slowPercent, _slowDuration);
        
        // 播放冰冻特效
        playFreezeEffect(target->getPosition());
    }
}

void IceTower::playFreezeEffect(const Vec2& pos) {
    auto effect = Sprite::create("effects/ice_hit.png");
    if (effect) {
        effect->setPosition(pos);
        this->getParent()->addChild(effect, 100);
        
        auto fade = FadeOut::create(0.5f);
        auto remove = RemoveSelf::create();
        effect->runAction(Sequence::create(fade, remove, nullptr));
    }
}
```

### 21.1.3 BuildingManager 注册

```cpp
// BuildingManager.cpp
Node* BuildingManager::createDefenceBuilding(int configId, int level) {
    const DefenceConfig* config = getDefenceConfig(configId);
    if (!config) return nullptr;
    
    // 根据建筑类型创建不同实例
    if (config->id == 1006) {  // IceTower
        return IceTower::create(config, level);
    }
    
    // 默认防御建筑
    return DefenceBuilding::create(config, level);
}
```

### 21.1.4 UI 图标添加

1. 将图标放入 `Resources/buildings/IceTower/`
2. 在 `BuildShopPanel` 中显示新建筑

---

## 21.2 添加新兵种

### 21.2.1 units_config.json 配置

```json
{
  "units": [
    // ... 现有兵种 ...
    {
      "id": 1010,
      "name": "Healer",
      "HP": [40, 50, 65, 80, 100],
      "ATK": [0, 0, 0, 0, 0],
      "ATK_SPEED": [2.0, 1.8, 1.6, 1.4, 1.2],
      "ATK_RANGE": [100, 110, 120, 130, 140],
      "SPEED": [50, 55, 60, 65, 70],
      "COST_COIN": 50,
      "COST_DIAMOND": 0,
      "MAXLEVEL": 4,
      "spriteFrameName": "unit/healer/healer.png",
      "spriteBaseName": "unit/healer/healer",
      "anim_idle": "idle",
      "anim_idle_frames": 4,
      "anim_idle_delay": 0.2,
      "anim_walk": "walk",
      "anim_walk_frames": 6,
      "anim_walk_delay": 0.12,
      "anim_attack": "heal",
      "anim_attack_frames": 4,
      "anim_attack_delay": 0.15,
      "anim_death": "death",
      "anim_death_frames": 3,
      "anim_death_delay": 0.12,
      "isRanged": true,
      "isFlying": false,
      "aiType": "HEALER",
      "healAmount": [10, 15, 20, 25, 30]
    }
  ]
}
```

### 21.2.2 动画资源准备

文件结构：
```
Resources/unit/healer/
├── healer.png           # 默认图片
├── healer_idle_1.png    # 待机帧
├── healer_idle_2.png
├── healer_idle_3.png
├── healer_idle_4.png
├── healer_walk_1.png    # 行走帧
├── healer_walk_2.png
├── healer_walk_3.png
├── healer_walk_4.png
├── healer_walk_5.png
├── healer_walk_6.png
├── healer_heal_1.png    # 治疗帧
├── healer_heal_2.png
├── healer_heal_3.png
├── healer_heal_4.png
├── healer_death_1.png   # 死亡帧
├── healer_death_2.png
└── healer_death_3.png
```

### 21.2.3 特殊技能实现

```cpp
// Classes/Soldier/Healer.h
class Healer : public Soldier {
public:
    static Healer* create(const UnitConfig* config, int level);
    
protected:
    void update(float dt) override;
    void findTarget() override;
    void performAction() override;
    
private:
    Soldier* findInjuredAlly();
    void healTarget(Soldier* target);
    float getHealAmount() const;
};

// Classes/Soldier/Healer.cpp
void Healer::findTarget() {
    // 治疗师寻找受伤的友军
    _currentTarget = findInjuredAlly();
}

Soldier* Healer::findInjuredAlly() {
    if (!s_friendlySoldiers || s_friendlySoldiers->empty()) {
        return nullptr;
    }
    
    Soldier* mostInjured = nullptr;
    float lowestHPRatio = 1.0f;
    
    for (Soldier* ally : *s_friendlySoldiers) {
        if (!ally || ally == this || ally->isDead()) continue;
        
        float hpRatio = ally->getCurrentHP() / ally->getMaxHP();
        
        // 只治疗受伤的
        if (hpRatio < 1.0f && hpRatio < lowestHPRatio) {
            float dist = this->getPosition().distance(ally->getPosition());
            if (dist <= getAttackRange()) {
                lowestHPRatio = hpRatio;
                mostInjured = ally;
            }
        }
    }
    
    return mostInjured;
}

void Healer::performAction() {
    if (!_currentTarget) return;
    
    auto* target = dynamic_cast<Soldier*>(_currentTarget);
    if (target && !target->isDead()) {
        healTarget(target);
    }
}

void Healer::healTarget(Soldier* target) {
    float heal = getHealAmount();
    target->heal(heal);
    
    // 播放治疗特效
    playHealEffect(target->getPosition());
    
    // 播放治疗动画
    playAnimation(AnimationType::ATTACK);
}
```

---

## 21.3 添加新关卡

### 21.3.1 BattleScene 中添加函数

```cpp
// BattleScene.cpp
void BattleScene::initLevel() {
    switch (_levelId) {
        case 1: createLevel1(); break;
        case 2: createLevel2(); break;
        // ... 现有关卡 ...
        case 13: createLevel13(); break;  // 新关卡
        default: createLevel1(); break;
    }
}

void BattleScene::createLevel13() {
    int towerLevel = resolveAttackTowerLevel(13);
    
    // 创建敌方基地
    createEnemyBase(28, 14, towerLevel);
    
    // 防御塔布局：双层防线
    // 外层
    createDefenseTower(10, 8, kTowerArrow, towerLevel);
    createDefenseTower(10, 20, kTowerArrow, towerLevel);
    createDefenseTower(14, 14, kTowerBoom, towerLevel);
    
    // 内层
    createDefenseTower(18, 10, kTowerMagic, towerLevel);
    createDefenseTower(18, 18, kTowerMagic, towerLevel);
    createDefenseTower(22, 14, kTowerFire, towerLevel);
    
    // 陷阱
    for (int x = 6; x <= 8; ++x) {
        for (int y = 12; y <= 16; ++y) {
            createSpikeTrap(x, y);
        }
    }
    
    createSnapTrap(12, 12);
    createSnapTrap(12, 16);
}
```

### 21.3.2 LevelSelectScene 更新

```cpp
// LevelSelectScene.cpp
void LevelSelectScene::setupLevelButtons() {
    int totalLevels = 13;  // 增加到 13 关
    
    for (int i = 1; i <= totalLevels; ++i) {
        auto btn = createLevelButton(i);
        // 布局代码...
    }
}
```

---

## 21.4 UI 面板开发

### 21.4.1 面板类创建

```cpp
// Classes/UI/StatsPanel.h
class StatsPanel : public Node {
public:
    static StatsPanel* create();
    bool init() override;
    
    void show();
    void hide();
    void refresh();
    
private:
    Node* _panel;
    Label* _totalKillsLabel;
    Label* _totalDeathsLabel;
    Label* _winRateLabel;
    
    void loadStats();
};
```

### 21.4.2 场景集成

```cpp
// MainMenuScene.cpp
bool MainMenuScene::init() {
    // ... 现有初始化 ...
    
    // 添加统计面板
    _statsPanel = StatsPanel::create();
    _statsPanel->setVisible(false);
    this->addChild(_statsPanel, 100);
    
    // 添加按钮
    auto statsBtn = createButton("Stats", [this]() {
        _statsPanel->show();
    });
    
    return true;
}
```

### 21.4.3 动画效果

```cpp
void StatsPanel::show() {
    this->setVisible(true);
    refresh();
    
    // 面板滑入动画
    _panel->setPositionX(visibleSize.width);
    _panel->runAction(
        EaseBackOut::create(
            MoveTo::create(0.3f, Vec2(visibleSize.width / 2, 
                                       visibleSize.height / 2))
        )
    );
}

void StatsPanel::hide() {
    _panel->runAction(Sequence::create(
        EaseBackIn::create(
            MoveTo::create(0.25f, Vec2(-200, visibleSize.height / 2))
        ),
        CallFunc::create([this]() {
            this->setVisible(false);
        }),
        nullptr
    ));
}
```

---

## 开发流程总结

```
┌─────────────────────────────────────────────────────────┐
│                    新功能开发流程                        │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  1. 需求分析                                             │
│       ↓                                                  │
│  2. 配置设计（JSON）                                     │
│       ↓                                                  │
│  3. 资源准备（贴图/动画/音效）                           │
│       ↓                                                  │
│  4. 代码实现                                             │
│       ↓                                                  │
│  5. 集成测试                                             │
│       ↓                                                  │
│  6. 调试优化                                             │
│       ↓                                                  │
│  7. 文档更新                                             │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

---

## 本章小结

1. **新建筑**：JSON 配置 + 继承 DefenceBuilding + 注册工厂
2. **新兵种**：JSON 配置 + 准备动画 + 继承 Soldier
3. **新关卡**：添加 createLevelX() + 更新选关界面
4. **新面板**：继承 Node + 实现 show/hide + 集成场景

---

**下一章**：[第22章 性能优化指南](第22章-性能优化指南.md)
