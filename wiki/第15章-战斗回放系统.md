# 第15章 战斗回放系统

> **本章目标**：理解 VoidKings 的战斗回放机制，掌握事件记录、序列化、播放等实现原理。

---

## 15.1 回放数据结构

### 15.1.1 BattleReplay 结构设计

```cpp
// Classes/Replay/ReplayManager.h

// 部署事件
struct ReplayDeployEvent {
    float time;        // 相对战斗开始的时间（秒）
    int unitId;        // 部署的兵种 ID
    int gridX;         // 部署位置 X
    int gridY;         // 部署位置 Y
    int level;         // 兵种等级
    
    rapidjson::Value toJson(rapidjson::Document::AllocatorType& alloc) const;
    static ReplayDeployEvent fromJson(const rapidjson::Value& obj);
};

// 完整回放数据
struct BattleReplay {
    int version = 1;                    // 回放版本
    int levelId = 1;                    // 关卡 ID
    bool defenseMode = false;           // 是否为防守模式
    float battleSpeed = 1.0f;           // 战斗倍速
    int64_t timestamp = 0;              // 战斗时间戳
    bool allowDefaultUnits = true;      // 是否使用默认兵种
    
    // 战斗结果
    bool resultWin = false;
    int resultStars = 0;
    
    // 初始兵种
    std::map<int, int> deployableUnits;
    
    // 事件列表
    std::vector<ReplayDeployEvent> events;
    
    // 序列化
    std::string toJsonString() const;
    static BattleReplay fromJsonString(const std::string& json);
};
```

### 15.1.2 部署事件记录

```cpp
// ReplayDeployEvent 序列化
rapidjson::Value ReplayDeployEvent::toJson(
    rapidjson::Document::AllocatorType& alloc) const {
    rapidjson::Value obj(rapidjson::kObjectType);
    obj.AddMember("t", time, alloc);         // 使用短键名节省空间
    obj.AddMember("u", unitId, alloc);
    obj.AddMember("x", gridX, alloc);
    obj.AddMember("y", gridY, alloc);
    obj.AddMember("l", level, alloc);
    return obj;
}

ReplayDeployEvent ReplayDeployEvent::fromJson(const rapidjson::Value& obj) {
    ReplayDeployEvent e;
    e.time = obj["t"].GetFloat();
    e.unitId = obj["u"].GetInt();
    e.gridX = obj["x"].GetInt();
    e.gridY = obj["y"].GetInt();
    e.level = obj.HasMember("l") ? obj["l"].GetInt() : 0;
    return e;
}
```

---

## 15.2 回放录制

### 15.2.1 初始化录制状态

```cpp
// BattleScene.cpp
void BattleScene::initRecording() {
    _currentReplay = BattleReplay();
    _currentReplay.levelId = _levelId;
    _currentReplay.defenseMode = (_battleMode == BattleMode::Defense);
    _currentReplay.battleSpeed = GameSettings::getBattleSpeed();
    _currentReplay.allowDefaultUnits = _allowDefaultUnits;
    
    // 记录时间戳
    auto now = std::chrono::system_clock::now();
    _currentReplay.timestamp = std::chrono::duration_cast<std::chrono::seconds>(
        now.time_since_epoch()).count();
    
    // 记录初始兵种
    _currentReplay.deployableUnits = _deployableUnits;
    
    _isRecording = true;
    CCLOG("[BattleScene] 开始录制回放");
}
```

### 15.2.2 recordDeployEvent() 事件捕获

```cpp
void BattleScene::recordDeployEvent(int unitId, int gridX, int gridY, int level) {
    if (!_isRecording) return;
    
    ReplayDeployEvent event;
    event.time = _battleTime;  // 当前战斗时间
    event.unitId = unitId;
    event.gridX = gridX;
    event.gridY = gridY;
    event.level = level;
    
    _currentReplay.events.push_back(event);
    
    CCLOG("[BattleScene] 记录部署: t=%.2f, unit=%d, pos=(%d,%d)",
          event.time, unitId, gridX, gridY);
}

// 在 deploySoldier 中调用
void BattleScene::deploySoldier(int unitId, const Vec2& worldPos) {
    // ... 部署逻辑 ...
    
    // 记录事件
    int gridX = static_cast<int>(gridPos.x);
    int gridY = static_cast<int>(gridPos.y);
    int level = UnitManager::getInstance()->getUnitLevel(unitId);
    
    recordDeployEvent(unitId, gridX, gridY, level);
}
```

### 15.2.3 finalizeReplay() 结果写入

```cpp
void BattleScene::finalizeReplay(bool win, int stars) {
    if (!_isRecording) return;
    
    _currentReplay.resultWin = win;
    _currentReplay.resultStars = stars;
    
    // 保存到 ReplayManager
    ReplayManager::getInstance()->setLastReplay(_currentReplay);
    
    _isRecording = false;
    CCLOG("[BattleScene] 回放录制完成: win=%d, stars=%d, events=%zu",
          win, stars, _currentReplay.events.size());
}
```

---

## 15.3 回放播放

### 15.3.1 createReplayScene() 场景创建

```cpp
Scene* BattleScene::createReplayScene(const BattleReplay& replay) {
    auto scene = new (std::nothrow) BattleScene();
    if (scene) {
        scene->_isReplay = true;
        scene->_hasReplayData = true;
        scene->_replayData = replay;
        scene->_replayEventIndex = 0;
        
        scene->setLevelId(replay.levelId);
        scene->setDeployableUnits(replay.deployableUnits);
        scene->_allowDefaultUnits = replay.allowDefaultUnits;
        scene->setBattleMode(replay.defenseMode ? 
            BattleMode::Defense : BattleMode::Attack);
        
        if (scene->init()) {
            scene->autorelease();
            return scene;
        }
    }
    CC_SAFE_DELETE(scene);
    return nullptr;
}
```

### 15.3.2 updateReplayPlayback() 事件驱动

```cpp
void BattleScene::updateReplayPlayback() {
    if (!_isReplay || !_hasReplayData) return;
    
    // 按时间顺序执行事件
    while (_replayEventIndex < _replayData.events.size()) {
        const auto& event = _replayData.events[_replayEventIndex];
        
        // 检查是否到达事件时间
        if (_battleTime < event.time) {
            break;  // 未到时间，等待
        }
        
        // 执行部署
        deployReplaySoldier(event);
        _replayEventIndex++;
    }
}

void BattleScene::deployReplaySoldier(const ReplayDeployEvent& event) {
    // 检查是否还有该兵种
    auto it = _deployableUnits.find(event.unitId);
    if (it == _deployableUnits.end() || it->second <= 0) {
        CCLOG("[Replay] 兵种不足: %d", event.unitId);
        return;
    }
    
    // 计算世界坐标
    float cellSize = _gridMap->getCellSize();
    Vec2 worldPos((event.gridX + 0.5f) * cellSize, 
                  (event.gridY + 0.5f) * cellSize);
    
    // 生成士兵（使用记录的等级）
    Soldier* soldier = UnitManager::getInstance()->spawnSoldier(
        event.unitId, worldPos, event.level);
    
    if (soldier) {
        _soldierLayer->addChild(soldier);
        _soldiers.push_back(soldier);
        soldier->retain();
        
        spawnDeployEffect(worldPos);
        
        it->second--;
        _totalDeployedCount++;
    }
}
```

### 15.3.3 时间戳同步

```cpp
void BattleScene::update(float dt) {
    if (_battleEnded || _battlePaused) return;
    
    // 更新战斗时间
    _battleTime += dt;
    
    // 回放模式：按时间戳播放
    if (_isReplay) {
        updateReplayPlayback();
    }
    
    // 更新战斗逻辑
    updateBattle(dt);
    
    // 更新 UI
    updateUI();
    
    // 检查结束
    checkBattleEnd();
}
```

---

## 15.4 回放序列化

### 15.4.1 JSON 导出

```cpp
// BattleReplay 序列化
std::string BattleReplay::toJsonString() const {
    rapidjson::Document doc;
    doc.SetObject();
    auto& alloc = doc.GetAllocator();
    
    doc.AddMember("version", version, alloc);
    doc.AddMember("levelId", levelId, alloc);
    doc.AddMember("defenseMode", defenseMode, alloc);
    doc.AddMember("battleSpeed", battleSpeed, alloc);
    doc.AddMember("timestamp", timestamp, alloc);
    doc.AddMember("allowDefaultUnits", allowDefaultUnits, alloc);
    doc.AddMember("resultWin", resultWin, alloc);
    doc.AddMember("resultStars", resultStars, alloc);
    
    // 初始兵种
    rapidjson::Value unitsVal(rapidjson::kArrayType);
    for (const auto& pair : deployableUnits) {
        rapidjson::Value item(rapidjson::kObjectType);
        item.AddMember("id", pair.first, alloc);
        item.AddMember("count", pair.second, alloc);
        unitsVal.PushBack(item, alloc);
    }
    doc.AddMember("deployableUnits", unitsVal, alloc);
    
    // 事件列表
    rapidjson::Value eventsVal(rapidjson::kArrayType);
    for (const auto& e : events) {
        eventsVal.PushBack(e.toJson(alloc), alloc);
    }
    doc.AddMember("events", eventsVal, alloc);
    
    rapidjson::StringBuffer buffer;
    rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
    doc.Accept(writer);
    
    return buffer.GetString();
}
```

### 15.4.2 JSON 导入

```cpp
BattleReplay BattleReplay::fromJsonString(const std::string& json) {
    BattleReplay replay;
    
    rapidjson::Document doc;
    doc.Parse(json.c_str());
    
    if (doc.HasParseError()) {
        CCLOG("[BattleReplay] JSON 解析错误");
        return replay;
    }
    
    replay.version = doc["version"].GetInt();
    replay.levelId = doc["levelId"].GetInt();
    replay.defenseMode = doc["defenseMode"].GetBool();
    replay.battleSpeed = doc["battleSpeed"].GetFloat();
    replay.timestamp = doc["timestamp"].GetInt64();
    replay.allowDefaultUnits = doc.HasMember("allowDefaultUnits") ? 
        doc["allowDefaultUnits"].GetBool() : true;
    replay.resultWin = doc["resultWin"].GetBool();
    replay.resultStars = doc["resultStars"].GetInt();
    
    // 兵种
    if (doc.HasMember("deployableUnits") && doc["deployableUnits"].IsArray()) {
        for (const auto& item : doc["deployableUnits"].GetArray()) {
            replay.deployableUnits[item["id"].GetInt()] = item["count"].GetInt();
        }
    }
    
    // 事件
    if (doc.HasMember("events") && doc["events"].IsArray()) {
        for (const auto& item : doc["events"].GetArray()) {
            replay.events.push_back(ReplayDeployEvent::fromJson(item));
        }
    }
    
    return replay;
}
```

### 15.4.3 文件路径管理

```cpp
// ReplayManager.cpp
bool ReplayManager::exportReplayTo(const std::string& path, 
                                    const BattleReplay& replay) {
    std::string json = replay.toJsonString();
    return FileUtils::getInstance()->writeStringToFile(json, path);
}

bool ReplayManager::importReplayFrom(const std::string& path, 
                                      BattleReplay& outReplay) {
    if (!FileUtils::getInstance()->isFileExist(path)) {
        return false;
    }
    
    std::string json = FileUtils::getInstance()->getStringFromFile(path);
    if (json.empty()) {
        return false;
    }
    
    outReplay = BattleReplay::fromJsonString(json);
    return outReplay.version > 0;
}

// 标准路径
std::string getReplayPath(const std::string& filename) {
    return FileUtils::getInstance()->getWritablePath() + 
           "share/" + filename;
}
```

---

## ReplayManager 单例

```cpp
class ReplayManager {
public:
    static ReplayManager* getInstance();
    
    // 最近一场回放
    void setLastReplay(const BattleReplay& replay);
    bool hasLastReplay() const;
    const BattleReplay& getLastReplay() const;
    void clearLastReplay();
    
    // 导入导出
    bool exportReplayTo(const std::string& path, const BattleReplay& replay);
    bool importReplayFrom(const std::string& path, BattleReplay& outReplay);
    
private:
    BattleReplay _lastReplay;
    bool _hasLastReplay = false;
};
```

---

## 本章小结

1. **BattleReplay** 存储完整战斗数据
2. **ReplayDeployEvent** 记录每次部署的时间和位置
3. **录制** 在战斗过程中捕获事件
4. **播放** 按时间戳顺序执行事件
5. **JSON 序列化** 支持文件导入导出

---

## 练习题

1. 添加回放快进功能：2x/4x 速度播放
2. 实现关键帧跳转：直接跳到某个时间点
3. 添加回放暂停/继续功能

---

**下一章**：[第16章 异步攻防系统](第16章-异步攻防系统.md)
