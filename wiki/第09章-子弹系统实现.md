# 第9章 子弹系统实现

> **本章目标**：理解 VoidKings 的子弹系统，包括追踪移动、命中检测、特效生成等机制。

---

## 9.1 Bullet 子弹基类

### 9.1.1 初始化与精灵创建

```cpp
// Classes/Bullet/Bullet.h
class Bullet : public Node {
public:
    static Bullet* create(const std::string& spriteFrame, 
                          float damage, float speed);
    virtual bool init(const std::string& spriteFrame, 
                      float damage, float speed);
    virtual void update(float dt) override;
    void onExit() override;

    void setTarget(Node* target);
    void setRotateToTarget(bool rotate, float offsetDegrees = 0.0f);
    float getDamage() const { return _damage; }
    
protected:
    Sprite* _sprite;
    Node* _target;
    float _damage;
    float _speed;
    bool _rotateToTarget = true;
    float _rotationOffsetDegrees = 0.0f;
    
    virtual void onReachTarget();
};
```

```cpp
// Classes/Bullet/Bullet.cpp
Bullet* Bullet::create(const std::string& spriteFrame, 
                        float damage, float speed) {
    Bullet* pRet = new(std::nothrow) Bullet();
    if (pRet && pRet->init(spriteFrame, damage, speed)) {
        pRet->autorelease();
        return pRet;
    }
    delete pRet;
    return nullptr;
}

bool Bullet::init(const std::string& spriteFrame, 
                   float damage, float speed) {
    if (!Node::init()) return false;

    _damage = damage;
    _speed = speed;
    _target = nullptr;
    _rotateToTarget = true;
    _rotationOffsetDegrees = 0.0f;

    // 创建子弹精灵
    _sprite = Sprite::create(spriteFrame);
    if (_sprite) {
        this->addChild(_sprite);
    }

    // 启动更新循环
    this->scheduleUpdate();
    return true;
}
```

### 9.1.2 目标跟踪更新

```cpp
void Bullet::update(float dt) {
    // 1. 检查目标是否有效
    if (!_target || !_target->getParent()) {
        // 目标已消失，移除子弹
        this->removeFromParent();
        return;
    }

    // 2. 获取目标世界坐标并转换到本地坐标
    auto* parent = this->getParent();
    auto* targetParent = _target->getParent();
    
    Vec2 targetWorld = targetParent
        ? targetParent->convertToWorldSpace(_target->getPosition())
        : _target->getPosition();
    
    Vec2 targetPos = parent 
        ? parent->convertToNodeSpace(targetWorld) 
        : targetWorld;

    // 3. 计算方向和距离
    Vec2 currentPos = this->getPosition();
    Vec2 diff = targetPos - currentPos;
    float distance = diff.length();

    // 4. 检查是否到达目标
    if (distance < 5.0f) {
        onReachTarget();
        this->removeFromParent();
        return;
    }

    // 5. 移动子弹
    Vec2 direction = diff.getNormalized();
    Vec2 newPos = currentPos + direction * _speed * dt;
    this->setPosition(newPos);

    // 6. 旋转子弹朝向目标
    if (_rotateToTarget && _sprite) {
        float angle = CC_RADIANS_TO_DEGREES(atan2(diff.y, diff.x));
        _sprite->setRotation(-angle + _rotationOffsetDegrees);
    }
}
```

### 9.1.3 朝向旋转计算

```cpp
// 计算子弹应该面向的角度
float angle = CC_RADIANS_TO_DEGREES(atan2(diff.y, diff.x));

// Cocos2d-x 的 rotation 是顺时针的，所以取负
// offsetDegrees 用于调整贴图初始朝向
_sprite->setRotation(-angle + _rotationOffsetDegrees);

// 示例：
// 如果箭头贴图默认朝右（0度），offsetDegrees = 0
// 如果箭头贴图默认朝上（90度），offsetDegrees = 90
```

### 9.1.4 到达目标处理

```cpp
void Bullet::onReachTarget() {
    // 基类的命中特效：冲击环
    auto* parent = this->getParent();
    if (!parent) return;

    auto ring = DrawNode::create();
    ring->drawCircle(Vec2::ZERO, 10.0f, 0.0f, 16, false, 
                     Color4F(1.0f, 1.0f, 1.0f, 0.8f));
    ring->setPosition(this->getPosition());
    parent->addChild(ring, this->getLocalZOrder());

    // 缩放 + 淡出动画
    auto scale = ScaleTo::create(0.22f, 1.6f);
    auto fade = FadeTo::create(0.22f, 0);
    ring->runAction(Sequence::create(
        Spawn::create(scale, fade, nullptr), 
        RemoveSelf::create(), 
        nullptr
    ));
}
```

---

## 9.2 命中特效

### 9.2.1 冲击环绘制

使用 `DrawNode` 绘制圆形：

```cpp
auto ring = DrawNode::create();

// 绘制空心圆
ring->drawCircle(
    Vec2::ZERO,       // 圆心（相对于 DrawNode）
    10.0f,            // 半径
    0.0f,             // 起始角度
    16,               // 线段数（越多越圆滑）
    false,            // 是否画半径线
    Color4F(1.0f, 1.0f, 1.0f, 0.8f)  // 颜色
);

// 绘制实心圆
ring->drawSolidCircle(Vec2::ZERO, 10.0f, 0.0f, 16, 
                       Color4F(1.0f, 0.5f, 0.0f, 0.5f));
```

### 9.2.2 缩放淡出动画

```cpp
// 组合动画：同时缩放和淡出
auto scale = ScaleTo::create(0.22f, 1.6f);  // 放大到 1.6 倍
auto fade = FadeTo::create(0.22f, 0);       // 淡出到透明

auto spawn = Spawn::create(scale, fade, nullptr);

// 动画结束后自动移除
auto sequence = Sequence::create(
    spawn,
    RemoveSelf::create(),
    nullptr
);

ring->runAction(sequence);
```

### 9.2.3 自动移除

```cpp
void Bullet::onExit() {
    // 释放目标引用
    if (_target) {
        _target->release();
        _target = nullptr;
    }
    Node::onExit();
}
```

---

## 9.3 防御塔子弹扩展

### 9.3.1 AOE 范围伤害

某些子弹需要造成范围伤害：

```cpp
// Classes/Bullet/AOEBullet.h
class AOEBullet : public Bullet {
public:
    static AOEBullet* create(const std::string& spriteFrame,
                              float damage, float speed, 
                              float aoeRadius);
    
    void setAOERadius(float radius) { _aoeRadius = radius; }
    
protected:
    void onReachTarget() override;
    
private:
    float _aoeRadius = 50.0f;
};

// Classes/Bullet/AOEBullet.cpp
void AOEBullet::onReachTarget() {
    // 1. 播放爆炸特效
    auto* parent = this->getParent();
    if (!parent) return;
    
    Vec2 hitPos = this->getPosition();
    
    // 爆炸圆
    auto explosion = DrawNode::create();
    explosion->drawSolidCircle(Vec2::ZERO, _aoeRadius, 0.0f, 24,
                                Color4F(1.0f, 0.5f, 0.0f, 0.6f));
    explosion->setPosition(hitPos);
    parent->addChild(explosion, 100);
    
    // 爆炸动画
    auto scale = ScaleTo::create(0.15f, 1.5f);
    auto fade = FadeOut::create(0.2f);
    explosion->runAction(Sequence::create(
        Spawn::create(scale, fade, nullptr),
        RemoveSelf::create(),
        nullptr
    ));
    
    // 2. 对范围内所有敌人造成伤害
    auto* soldiers = Soldier::getEnemySoldiers();
    if (!soldiers) return;
    
    for (Soldier* soldier : *soldiers) {
        if (!soldier || soldier->isDead()) continue;
        
        Vec2 soldierPos = soldier->getPosition();
        float dist = hitPos.distance(soldierPos);
        
        if (dist <= _aoeRadius) {
            // 距离越近，伤害越高
            float damageRatio = 1.0f - (dist / _aoeRadius) * 0.5f;
            float actualDamage = _damage * damageRatio;
            
            soldier->takeDamage(actualDamage);
        }
    }
    
    // 3. 播放爆炸音效
    AudioManager::playBoom();
}
```

### 9.3.2 空中/地面目标过滤

```cpp
// Classes/Bullet/FilteredBullet.h
class FilteredBullet : public Bullet {
public:
    void setTargetGround(bool canTarget) { _targetGround = canTarget; }
    void setTargetAir(bool canTarget) { _targetAir = canTarget; }
    
protected:
    void onReachTarget() override;
    
private:
    bool _targetGround = true;
    bool _targetAir = true;
};

void FilteredBullet::onReachTarget() {
    // 检查目标类型
    auto* soldier = dynamic_cast<Soldier*>(_target);
    if (soldier) {
        bool isFlying = soldier->isFlying();
        
        // 检查是否可以攻击
        if ((isFlying && !_targetAir) || (!isFlying && !_targetGround)) {
            // 无效目标，不造成伤害
            return;
        }
        
        soldier->takeDamage(_damage);
    }
    
    // 播放命中特效
    Bullet::onReachTarget();
}
```

### 9.3.3 命中音效分类

```cpp
// 根据子弹类型播放不同音效
void ArrowBullet::onReachTarget() {
    // 造成伤害
    if (auto* soldier = dynamic_cast<Soldier*>(_target)) {
        soldier->takeDamage(_damage);
    }
    
    // 播放命中音效
    AudioManager::playArrowHit();
    
    Bullet::onReachTarget();
}

void MagicBullet::onReachTarget() {
    if (auto* soldier = dynamic_cast<Soldier*>(_target)) {
        soldier->takeDamage(_damage);
    }
    
    AudioManager::playMagicHit();
    
    // 魔法特效
    spawnMagicHitEffect();
}

void CannonBullet::onReachTarget() {
    // AOE 伤害
    dealAOEDamage();
    
    AudioManager::playBoom();
    
    // 爆炸特效
    spawnExplosionEffect();
}
```

---

## 子弹系统架构图

```
┌─────────────────────────────────────────────────────────┐
│                        Bullet                            │
│  ├─ _sprite (子弹贴图)                                   │
│  ├─ _target (目标节点)                                   │
│  ├─ _damage (伤害值)                                     │
│  ├─ _speed (飞行速度)                                    │
│  ├─ update() (追踪移动)                                  │
│  └─ onReachTarget() (命中处理)                           │
└───────────────────────┬─────────────────────────────────┘
                        │
        ┌───────────────┼───────────────┐
        │               │               │
┌───────▼───────┐ ┌─────▼─────┐ ┌───────▼───────┐
│  ArrowBullet  │ │AOEBullet  │ │ MagicBullet   │
├───────────────┤ ├───────────┤ ├───────────────┤
│ 单体伤害      │ │ 范围伤害  │ │ 单体+特效    │
│ 箭矢贴图      │ │ 爆炸动画  │ │ 魔法特效     │
└───────────────┘ └───────────┘ └───────────────┘
```

---

## 子弹创建与发射

```cpp
// DefenceBuilding.cpp
void DefenceBuilding::attackTarget() {
    if (!_target) return;
    
    // 根据建筑类型选择子弹
    Bullet* bullet = nullptr;
    
    switch (_config->type) {
        case TowerType::ARROW:
            bullet = Bullet::create(
                _config->bulletSprite,
                getCurrentATK(),
                _config->bulletSpeed
            );
            break;
            
        case TowerType::BOOM:
            bullet = AOEBullet::create(
                _config->bulletSprite,
                getCurrentATK(),
                _config->bulletSpeed,
                _config->aoeRadius
            );
            break;
            
        case TowerType::MAGIC:
            bullet = MagicBullet::create(
                _config->bulletSprite,
                getCurrentATK(),
                _config->bulletSpeed
            );
            break;
    }
    
    if (bullet) {
        bullet->setPosition(this->getPosition());
        bullet->setTarget(_target);
        this->getParent()->addChild(bullet, 50);
    }
}
```

---

## 目标引用管理

```cpp
void Bullet::setTarget(Node* target) {
    if (_target == target) return;
    
    // 释放旧目标
    if (_target) {
        _target->release();
    }
    
    // 设置新目标
    _target = target;
    
    // 保持新目标引用
    if (_target) {
        _target->retain();
    }
}

void Bullet::onExit() {
    // 确保释放目标引用
    if (_target) {
        _target->release();
        _target = nullptr;
    }
    Node::onExit();
}
```

**为什么需要 retain/release？**

子弹飞行过程中，目标可能被其他攻击杀死并从场景移除。如果不 `retain`，目标节点可能被释放，导致悬空指针。

---

## 本章小结

1. **Bullet** 是追踪型子弹，自动飞向目标
2. **坐标转换** 确保不同父节点下的位置计算正确
3. **onReachTarget()** 处理命中逻辑和特效
4. **AOEBullet** 扩展支持范围伤害
5. **retain/release** 管理目标引用，防止悬空指针

---

## 练习题

1. 实现穿透子弹：命中后继续飞行一段距离
2. 添加弹道类型：直线/抛物线/追踪
3. 实现子弹时间：减速时子弹也变慢

---

**下一章**：[第10章 战斗场景 BattleScene](第10章-战斗场景BattleScene.md)
