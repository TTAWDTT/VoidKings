# 第4章 资源管理与经济系统

> **本章目标**：深入理解 VoidKings 的核心数据管理，掌握资源系统、等级机制和星级记录的实现原理。

---

## 4.1 Core 核心数据中心设计

### 4.1.1 资源类型枚举与哈希表存储

`Core` 类是游戏的核心数据中心，管理所有全局状态：

```cpp
// Classes/Core/Core.h

// 资源类型枚举
enum class ResourceType {
    COIN,       // 金币 - 用于训练兵种、建造建筑
    DIAMOND     // 钻石 - 用于升级、高级操作
};

// 自定义哈希函数（用于 unordered_map）
struct ResourceTypeHash {
    size_t operator()(ResourceType type) const {
        return static_cast<size_t>(type);
    }
};

class Core {
public:
    static Core* getInstance();
    
    // 资源操作
    int getResource(ResourceType type) const;
    void setResource(ResourceType type, int amount);
    void addResource(ResourceType type, int amount);
    bool consumeResource(ResourceType type, int amount);
    
private:
    // 资源存储
    std::unordered_map<ResourceType, int, ResourceTypeHash> _resources;
    
    // 统计数据
    std::unordered_map<ResourceType, long long, ResourceTypeHash> _totalEarned;
};
```

**为什么用 unordered_map 而不是 map？**
- `unordered_map`：O(1) 查找，适合频繁访问
- `map`：O(log n) 查找，有序但较慢
- 资源类型固定且少，unordered_map 更高效

### 4.1.2 自定义哈希函数实现

`std::unordered_map` 需要哈希函数来确定键的存储位置：

```cpp
struct ResourceTypeHash {
    size_t operator()(ResourceType type) const {
        // 直接将枚举值转换为 size_t
        return static_cast<size_t>(type);
    }
};

// 使用方式
std::unordered_map<ResourceType, int, ResourceTypeHash> _resources;
//                 键类型        值类型  哈希函数类型
```

**C++14 之后的简化写法**：
```cpp
// 使用 std::hash 特化
namespace std {
    template<>
    struct hash<ResourceType> {
        size_t operator()(ResourceType type) const noexcept {
            return static_cast<size_t>(type);
        }
    };
}

// 现在可以不指定哈希函数
std::unordered_map<ResourceType, int> _resources;
```

### 4.1.3 资源增减安全边界检查

```cpp
// Classes/Core/Core.cpp

int Core::getResource(ResourceType type) const {
    auto it = _resources.find(type);
    if (it != _resources.end()) {
        return it->second;
    }
    return 0;  // 默认返回 0
}

void Core::setResource(ResourceType type, int amount) {
    // 确保不为负
    _resources[type] = std::max(0, amount);
}

void Core::addResource(ResourceType type, int amount) {
    if (amount <= 0) return;  // 增加量必须为正
    
    _resources[type] += amount;
    _totalEarned[type] += amount;  // 累计获得
    
    CCLOG("[Core] 资源增加: type=%d, amount=%d, total=%d",
          static_cast<int>(type), amount, _resources[type]);
}

bool Core::consumeResource(ResourceType type, int amount) {
    if (amount <= 0) return false;
    
    int current = getResource(type);
    if (current < amount) {
        CCLOG("[Core] 资源不足: 需要 %d, 当前 %d", amount, current);
        return false;  // 余额不足
    }
    
    _resources[type] = current - amount;
    return true;
}
```

---

## 4.2 资源精灵与帧动画创建

### 4.2.1 createResourceSprite() 实现流程

为了显示旋转的金币/钻石动画：

```cpp
// Classes/Core/Core.cpp

Sprite* Core::createResourceSprite(ResourceType type, 
                                    float scale, 
                                    bool playAnimation) {
    // 1. 确定资源前缀
    std::string prefix;
    int frameCount = 0;
    
    switch (type) {
        case ResourceType::COIN:
            prefix = "res/coin_spin_";
            frameCount = 10;
            break;
        case ResourceType::DIAMOND:
            prefix = "res/diamond_spin_";
            frameCount = 8;
            break;
        default:
            return nullptr;
    }
    
    // 2. 加载第一帧作为静态图
    std::string firstFrame = prefix + "1.png";
    auto sprite = Sprite::create(firstFrame);
    if (!sprite) {
        CCLOG("[Core] 无法创建资源精灵: %s", firstFrame.c_str());
        return nullptr;
    }
    
    sprite->setScale(scale);
    
    // 3. 如果需要动画
    if (playAnimation) {
        auto anim = buildResourceAnimation(type, frameCount, prefix);
        if (anim) {
            sprite->runAction(RepeatForever::create(Animate::create(anim)));
        }
    }
    
    return sprite;
}
```

### 4.2.2 buildResourceAnimation() 帧加载

```cpp
Animation* Core::buildResourceAnimation(ResourceType type,
                                         int frameCount,
                                         const std::string& prefix) {
    Vector<SpriteFrame*> frames;
    
    auto cache = SpriteFrameCache::getInstance();
    
    for (int i = 1; i <= frameCount; ++i) {
        std::string frameName = StringUtils::format("%s%d.png", 
                                                     prefix.c_str(), i);
        
        // 优先从缓存获取
        auto frame = cache->getSpriteFrameByName(frameName);
        
        if (!frame) {
            // 缓存未命中，从文件加载
            auto texture = Director::getInstance()
                ->getTextureCache()->addImage(frameName);
            if (texture) {
                frame = SpriteFrame::createWithTexture(
                    texture,
                    Rect(0, 0, 
                         texture->getContentSize().width,
                         texture->getContentSize().height)
                );
                // 加入缓存供下次使用
                cache->addSpriteFrame(frame, frameName);
            }
        }
        
        if (frame) {
            frames.pushBack(frame);
        }
    }
    
    if (frames.empty()) {
        return nullptr;
    }
    
    // 创建动画，每帧显示 0.1 秒
    return Animation::createWithSpriteFrames(frames, 0.1f);
}
```

### 4.2.3 纹理缓存与 SpriteFrame 复用

```
首次加载流程:
┌─────────────┐    ┌──────────────┐    ┌────────────────┐
│ 文件系统    │ → │ TextureCache │ → │ SpriteFrameCache │
│ coin_1.png  │    │ 纹理数据     │    │ 帧引用          │
└─────────────┘    └──────────────┘    └────────────────┘

后续加载:
┌────────────────┐
│ SpriteFrameCache │ → 直接返回（O(1) 查找）
└────────────────┘
```

### 4.2.4 循环动画 RepeatForever 播放

```cpp
// 创建循环动画
auto animate = Animate::create(animation);
auto repeat = RepeatForever::create(animate);
sprite->runAction(repeat);

// 停止动画
sprite->stopAllActions();

// 暂停/恢复动画
sprite->pause();
sprite->resume();
```

---

## 4.3 基地等级与升级机制

### 4.3.1 等级对生产速度的影响

```cpp
// Classes/Core/Core.h
class Core {
    int _baseLevel = 1;  // 基地等级，从 1 开始
    
public:
    int getBaseLevel() const { return _baseLevel; }
    void setBaseLevel(int level);
    
    // 生产速度倍率：等级越高，生产越快
    float getBaseProduceSpeedMultiplier() const;
    
    // 训练费用倍率：等级越高，训练越便宜
    float getTrainingCostMultiplier() const;
};

// Classes/Core/Core.cpp
float Core::getBaseProduceSpeedMultiplier() const {
    // 等级 1: 1.0x
    // 等级 2: 1.15x
    // 等级 3: 1.30x
    // ...
    return 1.0f + static_cast<float>(_baseLevel - 1) * 0.15f;
}

float Core::getTrainingCostMultiplier() const {
    // 等级 1: 1.0x（原价）
    // 等级 2: 0.95x（5% 折扣）
    // 等级 3: 0.90x（10% 折扣）
    // 最低 0.7x
    float discount = 1.0f - static_cast<float>(_baseLevel - 1) * 0.05f;
    return std::max(0.7f, discount);
}
```

### 4.3.2 升级消耗计算

```cpp
int Core::getBaseUpgradeCost() const {
    // 升级费用随等级指数增长
    // 等级 1→2: 100 钻石
    // 等级 2→3: 200 钻石
    // 等级 3→4: 400 钻石
    return 100 * static_cast<int>(std::pow(2, _baseLevel - 1));
}

bool Core::upgradeBase() {
    int cost = getBaseUpgradeCost();
    
    // 检查是否达到最高等级
    if (_baseLevel >= MAX_BASE_LEVEL) {
        CCLOG("[Core] 已达最高等级");
        return false;
    }
    
    // 检查钻石是否足够
    if (!consumeResource(ResourceType::DIAMOND, cost)) {
        CCLOG("[Core] 钻石不足，需要 %d", cost);
        return false;
    }
    
    _baseLevel++;
    CCLOG("[Core] 基地升级到等级 %d", _baseLevel);
    return true;
}
```

### 4.3.3 训练费用折扣逻辑

在 `TrainPanel` 中应用折扣：

```cpp
// UI/TrainPanel.cpp
int resolveRecruitCost(const UnitConfig* config) {
    if (!config) return DEFAULT_COST;
    
    int baseCost = config->COST_COIN > 0 
        ? config->COST_COIN 
        : DEFAULT_COST;
    
    // 应用等级折扣
    float multiplier = Core::getInstance()->getTrainingCostMultiplier();
    int cost = static_cast<int>(std::round(baseCost * multiplier));
    
    return std::max(1, cost);  // 至少 1 金币
}
```

---

## 4.4 关卡星级记录系统

### 4.4.1 星级数据结构设计

```cpp
// Classes/Core/Core.h
class Core {
private:
    // 关卡星级：levelId → stars (0-3)
    std::map<int, int> _levelStars;
    
public:
    int getLevelStars(int levelId) const;
    void setLevelStars(int levelId, int stars);
    
    // 获取所有星级数据（用于存档）
    const std::map<int, int>& getLevelStarsData() const;
    void setLevelStarsData(const std::vector<std::pair<int, int>>& data);
};
```

### 4.4.2 只记录最高星级策略

```cpp
// Classes/Core/Core.cpp
int Core::getLevelStars(int levelId) const {
    auto it = _levelStars.find(levelId);
    if (it != _levelStars.end()) {
        return it->second;
    }
    return 0;  // 未通关返回 0 星
}

void Core::setLevelStars(int levelId, int stars) {
    // 限制在 0-3 范围
    stars = std::max(0, std::min(3, stars));
    
    // 只保留最高星级
    int current = getLevelStars(levelId);
    if (stars > current) {
        _levelStars[levelId] = stars;
        CCLOG("[Core] 关卡 %d 星级更新: %d → %d", 
              levelId, current, stars);
    }
}
```

### 4.4.3 星级数据序列化

```cpp
// 存档时序列化
void SaveManager::serializeLevelStars(rapidjson::Document& doc) {
    auto& alloc = doc.GetAllocator();
    rapidjson::Value stars(rapidjson::kArrayType);
    
    for (const auto& pair : Core::getInstance()->getLevelStarsData()) {
        rapidjson::Value item(rapidjson::kObjectType);
        item.AddMember("id", pair.first, alloc);
        item.AddMember("stars", pair.second, alloc);
        stars.PushBack(item, alloc);
    }
    
    doc["core"].AddMember("levelStars", stars, alloc);
}

// 读档时反序列化
void SaveManager::deserializeLevelStars(const rapidjson::Value& core) {
    if (!core.HasMember("levelStars") || !core["levelStars"].IsArray()) {
        return;
    }
    
    std::vector<std::pair<int, int>> data;
    for (const auto& item : core["levelStars"].GetArray()) {
        int id = item["id"].GetInt();
        int stars = item["stars"].GetInt();
        data.emplace_back(id, stars);
    }
    
    Core::getInstance()->setLevelStarsData(data);
}
```

---

## 资源收集动画效果

```cpp
// BaseScene.cpp
void BaseScene::playCollectEffect(const Vec2& buildingPos, 
                                   ResourceType type, 
                                   int amount) {
    // 1. 创建资源精灵
    auto sprite = Core::getInstance()->createResourceSprite(type, 0.8f, true);
    if (!sprite) return;
    
    // 2. 设置初始位置（建筑上方）
    sprite->setPosition(buildingPos + Vec2(0, 30));
    _effectLayer->addChild(sprite, 100);
    
    // 3. 获取 HUD 资源图标位置
    Vec2 targetPos = getResourceIconPosition(type);
    
    // 4. 创建动画序列
    auto move = MoveTo::create(0.6f, targetPos);
    auto ease = EaseOut::create(move, 2.0f);  // 先快后慢
    auto fade = FadeOut::create(0.2f);
    auto scale = ScaleTo::create(0.6f, 0.3f);
    
    auto spawn = Spawn::create(ease, scale, nullptr);
    auto sequence = Sequence::create(
        spawn,
        fade,
        CallFunc::create([this, type, amount]() {
            // 5. 动画结束时添加资源并更新 UI
            Core::getInstance()->addResource(type, amount);
            this->updateResourceDisplay();
        }),
        RemoveSelf::create(),
        nullptr
    );
    
    sprite->runAction(sequence);
    
    // 6. 播放音效
    AudioManager::playMoneyGet();
}
```

---

## 本章小结

1. **Core 单例** 管理所有全局资源数据
2. **unordered_map** 提供 O(1) 的资源访问
3. **SpriteFrameCache** 缓存动画帧，避免重复加载
4. **基地等级** 影响生产速度和训练费用
5. **星级系统** 只保留最高记录，便于存档

---

## 数据流图

```
┌──────────────────────────────────────────────────────────────┐
│                        Core 数据中心                          │
├──────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐   │
│  │  COIN   │    │ DIAMOND │    │BaseLevel│    │LevelStars│   │
│  │  金币   │    │  钻石   │    │ 基地等级 │    │ 关卡星级 │   │
│  └────┬────┘    └────┬────┘    └────┬────┘    └────┬────┘   │
│       │              │              │              │         │
│       ▼              ▼              ▼              ▼         │
│  ┌─────────────────────────────────────────────────────────┐│
│  │                    SaveManager                           ││
│  │                    存档/读档                              ││
│  └─────────────────────────────────────────────────────────┘│
│                                                               │
└──────────────────────────────────────────────────────────────┘
        │                │                │
        ▼                ▼                ▼
  ┌──────────┐    ┌──────────┐    ┌──────────┐
  │TrainPanel│    │BaseScene │    │BattleScene│
  │ 训练面板 │    │ 基地场景 │    │ 战斗场景 │
  └──────────┘    └──────────┘    └──────────┘
```

---

## 练习题

1. 添加第三种资源类型"圣水"（ELIXIR），并在 UI 中显示
2. 修改升级费用公式，使其增长更平缓
3. 实现资源上限机制：金币最多存储 10000

---

**下一章**：[第5章 建筑系统完整实现](第05章-建筑系统完整实现.md)
