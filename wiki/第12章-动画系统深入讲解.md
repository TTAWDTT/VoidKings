# 第12章 动画系统深入讲解

> **本章目标**：掌握 Cocos2d-x 动画系统，理解帧动画、缓存机制、状态切换等实现原理。

---

## 12.1 帧动画基础

### 12.1.1 SpriteFrame 与 Animation

**核心概念**：

```
Texture (纹理) → SpriteFrame (精灵帧) → Animation (动画) → Animate (动作)
     ↑                   ↑                    ↑
   图片文件          帧区域定义            帧序列+时间
```

```cpp
// SpriteFrame：从纹理中截取一个矩形区域
auto texture = Director::getInstance()->getTextureCache()->addImage("sheet.png");
auto frame = SpriteFrame::createWithTexture(texture, Rect(0, 0, 64, 64));

// Animation：多个 SpriteFrame 组成动画
Vector<SpriteFrame*> frames;
frames.pushBack(frame1);
frames.pushBack(frame2);
frames.pushBack(frame3);
auto animation = Animation::createWithSpriteFrames(frames, 0.1f);  // 每帧 0.1 秒

// Animate：播放动画的动作
auto animate = Animate::create(animation);
sprite->runAction(animate);
```

### 12.1.2 帧命名规范

VoidKings 使用统一的命名规范：

```
{baseName}_{animKey}_{frameNumber}.png

示例：
unit/spearman/spearman_idle_1.png
unit/spearman/spearman_idle_2.png
unit/spearman/spearman_walk_1.png
unit/spearman/spearman_walk_2.png
unit/spearman/spearman_attack_1.png
```

**解析规则**：
- `baseName`：基础名称，如 `unit/spearman/spearman`
- `animKey`：动画类型，如 `idle`、`walk`、`attack`
- `frameNumber`：帧序号，从 1 开始

### 12.1.3 Animation 创建流程

```cpp
Animation* createAnimationFromFiles(
    const std::string& baseName,
    const std::string& animKey,
    int frameCount,
    float delayPerFrame)
{
    Vector<SpriteFrame*> frames;
    
    for (int i = 1; i <= frameCount; ++i) {
        // 构造文件名
        std::string filename = StringUtils::format(
            "%s_%s_%d.png", baseName.c_str(), animKey.c_str(), i);
        
        // 加载纹理
        auto texture = Director::getInstance()
            ->getTextureCache()->addImage(filename);
        
        if (texture) {
            // 创建 SpriteFrame
            auto frame = SpriteFrame::createWithTexture(
                texture,
                Rect(0, 0, 
                     texture->getContentSize().width,
                     texture->getContentSize().height)
            );
            frames.pushBack(frame);
        }
    }
    
    if (frames.empty()) {
        return nullptr;
    }
    
    return Animation::createWithSpriteFrames(frames, delayPerFrame);
}
```

---

## 12.2 AnimationUtils 工具类

### 12.2.1 buildAnimationFromFrames() 源码

```cpp
// Classes/Utils/AnimationUtils.h
namespace AnimationUtils {
    Animation* buildAnimationFromFrames(
        const std::string& baseName,
        const std::string& animKey,
        int frameCount,
        float delay,
        bool useCache = true
    );
    
    void clearCache();
}

// Classes/Utils/AnimationUtils.cpp
Animation* AnimationUtils::buildAnimationFromFrames(
    const std::string& baseName,
    const std::string& animKey,
    int frameCount,
    float delay,
    bool useCache)
{
    // 1. 生成缓存键
    std::string cacheKey = baseName + "_" + animKey;
    
    // 2. 检查缓存
    if (useCache) {
        auto cached = AnimationCache::getInstance()->getAnimation(cacheKey);
        if (cached) {
            return cached;
        }
    }
    
    // 3. 加载帧
    Vector<SpriteFrame*> frames;
    auto frameCache = SpriteFrameCache::getInstance();
    auto textureCache = Director::getInstance()->getTextureCache();
    
    for (int i = 1; i <= frameCount; ++i) {
        std::string frameName = StringUtils::format(
            "%s_%s_%d.png", baseName.c_str(), animKey.c_str(), i);
        
        // 优先从 SpriteFrameCache 获取
        auto frame = frameCache->getSpriteFrameByName(frameName);
        
        if (!frame) {
            // 从文件加载
            auto texture = textureCache->addImage(frameName);
            if (texture) {
                frame = SpriteFrame::createWithTexture(
                    texture,
                    Rect(0, 0, 
                         texture->getContentSize().width,
                         texture->getContentSize().height)
                );
                // 加入缓存
                frameCache->addSpriteFrame(frame, frameName);
            }
        }
        
        if (frame) {
            frames.pushBack(frame);
        }
    }
    
    // 4. 创建动画
    if (frames.empty()) {
        CCLOG("[AnimationUtils] 未找到帧: %s", cacheKey.c_str());
        return nullptr;
    }
    
    auto animation = Animation::createWithSpriteFrames(frames, delay);
    
    // 5. 存入缓存
    if (useCache && animation) {
        AnimationCache::getInstance()->addAnimation(animation, cacheKey);
    }
    
    return animation;
}
```

### 12.2.2 SpriteFrameCache 复用

```cpp
// 全局精灵帧缓存
auto cache = SpriteFrameCache::getInstance();

// 从 plist 批量加载（推荐）
cache->addSpriteFramesWithFile("textures/units.plist");

// 获取帧
auto frame = cache->getSpriteFrameByName("spearman_idle_1.png");

// 使用帧创建精灵
auto sprite = Sprite::createWithSpriteFrame(frame);
```

### 12.2.3 AnimationCache 缓存

```cpp
// 动画缓存
auto animCache = AnimationCache::getInstance();

// 存储动画
animCache->addAnimation(walkAnim, "soldier_walk");

// 获取动画
auto anim = animCache->getAnimation("soldier_walk");

// 清除所有缓存
animCache->destroyInstance();
```

---

## 12.3 士兵动画系统

### 12.3.1 待机/行走/攻击/死亡动画

```cpp
// Soldier.cpp
enum class AnimationType {
    IDLE,
    WALK,
    ATTACK,
    DEATH
};

void Soldier::playAnimation(AnimationType type) {
    if (!_bodySprite || !_config) return;
    
    std::string animKey;
    int frameCount = 0;
    float delay = 0.1f;
    bool loop = true;
    
    switch (type) {
        case AnimationType::IDLE:
            animKey = _config->anim_idle;
            frameCount = _config->anim_idle_frames;
            delay = _config->anim_idle_delay;
            break;
            
        case AnimationType::WALK:
            animKey = _config->anim_walk;
            frameCount = _config->anim_walk_frames;
            delay = _config->anim_walk_delay;
            break;
            
        case AnimationType::ATTACK:
            animKey = _config->anim_attack;
            frameCount = _config->anim_attack_frames;
            delay = _config->anim_attack_delay;
            loop = false;
            break;
            
        case AnimationType::DEATH:
            animKey = _config->anim_death;
            frameCount = _config->anim_death_frames;
            delay = _config->anim_death_delay;
            loop = false;
            break;
    }
    
    // 构建动画
    auto animation = AnimationUtils::buildAnimationFromFrames(
        _config->spriteBaseName, animKey, frameCount, delay, true);
    
    if (!animation) return;
    
    // 停止当前动画
    _bodySprite->stopAllActions();
    
    // 播放新动画
    auto animate = Animate::create(animation);
    
    if (loop) {
        _bodySprite->runAction(RepeatForever::create(animate));
    } else {
        _bodySprite->runAction(animate);
    }
    
    _currentAnimType = type;
}
```

### 12.3.2 方向处理与精灵翻转

```cpp
void Soldier::updateSpriteDirection(const Vec2& moveDirection) {
    if (!_bodySprite) return;
    
    // 只在 X 方向有明显变化时翻转
    if (moveDirection.x < -0.1f) {
        // 向左移动：翻转精灵
        float absScaleX = std::abs(_bodySprite->getScaleX());
        _bodySprite->setScaleX(-absScaleX);
    } else if (moveDirection.x > 0.1f) {
        // 向右移动：正常显示
        float absScaleX = std::abs(_bodySprite->getScaleX());
        _bodySprite->setScaleX(absScaleX);
    }
    // X 接近 0 时保持当前朝向
}
```

### 12.3.3 动画状态机切换

```cpp
void Soldier::update(float dt) {
    if (isDead()) return;
    
    // 确定目标状态
    AnimationType targetAnim;
    
    if (_state == SoldierState::ATTACKING) {
        targetAnim = AnimationType::ATTACK;
    } else if (_state == SoldierState::MOVING) {
        targetAnim = AnimationType::WALK;
    } else {
        targetAnim = AnimationType::IDLE;
    }
    
    // 状态切换时播放动画
    if (targetAnim != _currentAnimType) {
        playAnimation(targetAnim);
    }
    
    // 执行行为
    switch (_state) {
        case SoldierState::MOVING:
            moveToTarget(dt);
            break;
        case SoldierState::ATTACKING:
            attackTarget(dt);
            break;
    }
}
```

---

## 12.4 建筑动画系统

### 12.4.1 待机动画自动播放

```cpp
// DefenceBuilding.cpp
bool DefenceBuilding::init(const DefenceConfig* config, int level) {
    // ... 其他初始化 ...
    
    // 尝试播放待机动画
    if (!config->anim_idle.empty() && config->anim_idle_frames > 0) {
        auto animation = AnimationUtils::buildAnimationFromFrames(
            config->spriteBaseName,
            config->anim_idle,
            config->anim_idle_frames,
            config->anim_idle_delay,
            true
        );
        
        if (animation && _bodySprite) {
            _bodySprite->runAction(
                RepeatForever::create(Animate::create(animation)));
        }
    }
    
    return true;
}
```

### 12.4.2 攻击动画触发

```cpp
void DefenceBuilding::playAttackAnimation() {
    if (!_bodySprite || !_config) return;
    
    // 如果有攻击动画
    if (!_config->anim_attack.empty() && _config->anim_attack_frames > 0) {
        auto animation = AnimationUtils::buildAnimationFromFrames(
            _config->spriteBaseName,
            _config->anim_attack,
            _config->anim_attack_frames,
            _config->anim_attack_delay,
            true
        );
        
        if (animation) {
            _bodySprite->stopAllActions();
            
            auto animate = Animate::create(animation);
            auto callback = CallFunc::create([this]() {
                // 攻击动画结束后恢复待机
                playIdleAnimation();
            });
            
            _bodySprite->runAction(Sequence::create(animate, callback, nullptr));
        }
    } else {
        // 无攻击动画，使用缩放反馈
        playAttackFeedback();
    }
}
```

### 12.4.3 无动画时的缩放反馈

```cpp
void DefenceBuilding::playAttackFeedback() {
    if (!_bodySprite) return;
    
    // 快速缩放表示攻击
    auto scaleUp = ScaleTo::create(0.05f, 1.1f);
    auto scaleDown = ScaleTo::create(0.1f, 1.0f);
    
    _bodySprite->runAction(Sequence::create(scaleUp, scaleDown, nullptr));
}
```

---

## 12.5 特效动画

### 12.5.1 资源收集飞行效果

```cpp
void BaseScene::playCollectEffect(const Vec2& startPos, 
                                   ResourceType type, 
                                   int amount) {
    // 创建资源精灵
    auto sprite = Core::getInstance()->createResourceSprite(type, 0.8f, true);
    if (!sprite) return;
    
    // 初始位置
    sprite->setPosition(startPos + Vec2(0, 30));
    _effectLayer->addChild(sprite, 100);
    
    // 目标位置（HUD 资源图标）
    Vec2 targetPos = getResourceIconPosition(type);
    
    // 贝塞尔曲线路径
    Vec2 control = Vec2(
        (startPos.x + targetPos.x) / 2,
        std::max(startPos.y, targetPos.y) + 50
    );
    
    ccBezierConfig bezier;
    bezier.controlPoint_1 = control;
    bezier.controlPoint_2 = control;
    bezier.endPosition = targetPos;
    
    auto bezierMove = BezierTo::create(0.6f, bezier);
    auto ease = EaseOut::create(bezierMove, 2.0f);
    auto scale = ScaleTo::create(0.6f, 0.3f);
    auto fade = FadeOut::create(0.15f);
    
    sprite->runAction(Sequence::create(
        Spawn::create(ease, scale, nullptr),
        fade,
        CallFunc::create([this, type, amount]() {
            Core::getInstance()->addResource(type, amount);
            updateResourceDisplay();
        }),
        RemoveSelf::create(),
        nullptr
    ));
    
    AudioManager::playMoneyGet();
}
```

### 12.5.2 部署冲击环效果

```cpp
void BattleScene::spawnDeployEffect(const Vec2& position) {
    auto ring = DrawNode::create();
    ring->drawCircle(Vec2::ZERO, 14.0f, 0.0f, 20, false, 
                     Color4F(0.8f, 1.0f, 0.8f, 0.8f));
    ring->setPosition(position);
    _gridMap->addChild(ring, 30);

    auto scale = ScaleTo::create(0.25f, 1.6f);
    auto fade = FadeTo::create(0.25f, 0);
    ring->runAction(Sequence::create(
        Spawn::create(scale, fade, nullptr), 
        RemoveSelf::create(), 
        nullptr
    ));
}
```

### 12.5.3 受伤闪白效果

```cpp
// Classes/Utils/EffectUtils.cpp
void EffectUtils::playHitFlash(Sprite* sprite) {
    if (!sprite) return;
    
    // 停止之前的闪白效果
    sprite->stopActionByTag(TAG_HIT_FLASH);
    
    // 创建闪白动画
    auto tintRed = TintTo::create(0.0f, 255, 100, 100);
    auto delay = DelayTime::create(0.05f);
    auto tintBack = TintTo::create(0.1f, 255, 255, 255);
    
    auto action = Sequence::create(tintRed, delay, tintBack, nullptr);
    action->setTag(TAG_HIT_FLASH);
    
    sprite->runAction(action);
}

// 使用方式
void Soldier::takeDamage(float damage) {
    _currentHP -= damage;
    
    // 播放受伤闪白
    EffectUtils::playHitFlash(_bodySprite);
    
    if (_currentHP <= 0) {
        onDeath();
    }
}
```

---

## 本章小结

1. **SpriteFrame** 是动画的基础单位
2. **Animation** 由多个 SpriteFrame 和时间信息组成
3. **缓存机制** 避免重复加载，提高性能
4. **状态机** 管理动画切换，避免冲突
5. **特效动画** 提升游戏反馈感

---

## 练习题

1. 为士兵添加"被治疗"动画效果（绿色闪光）
2. 实现建筑被攻击时的震动效果
3. 添加金币收集时的"+100"飘字效果

---

**下一章**：[第13章 音频系统](第13章-音频系统.md)
