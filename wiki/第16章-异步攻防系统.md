# 第16章 异步攻防（伪联机）系统

> **本章目标**：理解 VoidKings 的离线 PvP 机制，掌握基地快照导出/导入、战斗回放分享的实现。

---

## 16.1 系统设计理念

### 16.1.1 离线 PvP 概念

VoidKings 实现了一种**离线异步对战**模式：

```
┌──────────────────────────────────────────────────────────┐
│                    异步攻防流程                           │
├──────────────────────────────────────────────────────────┤
│                                                          │
│  玩家 A                          玩家 B                  │
│  ┌─────────────┐                ┌─────────────┐         │
│  │ 设计基地    │                │             │         │
│  │ 布置防御    │                │             │         │
│  └──────┬──────┘                │             │         │
│         │                       │             │         │
│         ▼                       │             │         │
│  ┌─────────────┐                │             │         │
│  │导出基地快照 │ ──────────────▶│导入快照     │         │
│  │my_base.json │                │target_base  │         │
│  └─────────────┘                └──────┬──────┘         │
│                                        │                │
│                                        ▼                │
│                                 ┌─────────────┐         │
│                                 │ 进攻基地    │         │
│                                 │ 战斗录制    │         │
│                                 └──────┬──────┘         │
│         ┌──────────────────────────────┘                │
│         ▼                                               │
│  ┌─────────────┐                                        │
│  │导入回放     │◀──────────────────────────────────────│
│  │target_replay│                                        │
│  └──────┬──────┘                                        │
│         ▼                                               │
│  ┌─────────────┐                                        │
│  │ 观看回放    │                                        │
│  │ 改进防御    │                                        │
│  └─────────────┘                                        │
│                                                          │
└──────────────────────────────────────────────────────────┘
```

### 16.1.2 文件交换模式

所有数据通过本地文件交换：

```
share/
├── my_base_snapshot.json     # 自己导出的基地
├── target_base_snapshot.json # 对方的基地（导入后重命名）
├── last_replay.json          # 最近一场战斗回放
└── target_replay.json        # 对方的回放（导入后重命名）
```

### 16.1.3 配置一致性校验

为确保双方使用相同的游戏配置：

```cpp
std::string BattleShareManager::computeConfigHash() {
    // 读取配置文件内容
    std::string buildings = FileUtils::getInstance()
        ->getStringFromFile("res/buildings_config.json");
    std::string units = FileUtils::getInstance()
        ->getStringFromFile("res/units_config.json");
    
    // 拼接并计算哈希
    std::string combined = buildings + units;
    
    // 简单哈希（实际可用 MD5/SHA）
    std::hash<std::string> hasher;
    size_t hash = hasher(combined);
    
    return StringUtils::format("%zu", hash);
}
```

---

## 16.2 基地快照导出

### 16.2.1 BaseSnapshot 数据结构

```cpp
// Classes/Share/BattleShareManager.h
struct BaseSnapshot {
    int version = 1;
    std::string configHash;     // 配置文件哈希
    int baseLevel = 0;          // 基地等级
    int barracksLevel = 0;      // 兵营等级
    Vec2 baseAnchor;            // 基地位置
    Vec2 barracksAnchor;        // 兵营位置
    std::vector<BaseSavedBuilding> buildings;  // 建筑列表
    
    std::string toJsonString() const;
    static BaseSnapshot fromJsonString(const std::string& json);
};
```

### 16.2.2 captureCurrentBase() 实现

```cpp
BaseSnapshot BattleShareManager::captureCurrentBase() {
    BaseSnapshot snapshot;
    snapshot.version = 1;
    snapshot.configHash = computeConfigHash();
    snapshot.baseLevel = Core::getInstance()->getBaseLevel();
    
    // 获取主基地位置
    auto* baseScene = dynamic_cast<BaseScene*>(
        Director::getInstance()->getRunningScene()->getChildByName("BaseScene"));
    
    if (baseScene) {
        snapshot.baseAnchor = baseScene->getBaseAnchor();
        snapshot.barracksAnchor = baseScene->getBarracksAnchor();
    }
    
    // 复制建筑列表
    snapshot.buildings = BaseScene::getSavedBuildings();
    
    return snapshot;
}
```

### 16.2.3 JSON 序列化

```cpp
std::string BaseSnapshot::toJsonString() const {
    rapidjson::Document doc;
    doc.SetObject();
    auto& alloc = doc.GetAllocator();
    
    doc.AddMember("version", version, alloc);
    
    rapidjson::Value hashVal;
    hashVal.SetString(configHash.c_str(), alloc);
    doc.AddMember("configHash", hashVal, alloc);
    
    doc.AddMember("baseLevel", baseLevel, alloc);
    doc.AddMember("barracksLevel", barracksLevel, alloc);
    
    // 锚点
    rapidjson::Value baseAnchorVal(rapidjson::kObjectType);
    baseAnchorVal.AddMember("x", baseAnchor.x, alloc);
    baseAnchorVal.AddMember("y", baseAnchor.y, alloc);
    doc.AddMember("baseAnchor", baseAnchorVal, alloc);
    
    // 建筑列表
    rapidjson::Value buildingsVal(rapidjson::kArrayType);
    for (const auto& b : buildings) {
        buildingsVal.PushBack(b.toJson(alloc), alloc);
    }
    doc.AddMember("buildings", buildingsVal, alloc);
    
    rapidjson::StringBuffer buffer;
    rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
    doc.Accept(writer);
    
    return buffer.GetString();
}
```

### 16.2.4 导出到文件

```cpp
bool BattleShareManager::exportPlayerBaseSnapshot() {
    BaseSnapshot snapshot = captureCurrentBase();
    std::string json = snapshot.toJsonString();
    
    std::string path = getSharePath("my_base_snapshot.json");
    bool success = FileUtils::getInstance()->writeStringToFile(json, path);
    
    if (success) {
        CCLOG("[BattleShareManager] 基地快照已导出: %s", path.c_str());
    }
    
    return success;
}
```

---

## 16.3 基地快照导入

### 16.3.1 文件读取与解析

```cpp
bool BattleShareManager::loadIncomingSnapshot() {
    std::string path = getSharePath("target_base_snapshot.json");
    
    if (!FileUtils::getInstance()->isFileExist(path)) {
        CCLOG("[BattleShareManager] 目标快照不存在");
        return false;
    }
    
    std::string json = FileUtils::getInstance()->getStringFromFile(path);
    if (json.empty()) {
        return false;
    }
    
    _targetSnapshot = BaseSnapshot::fromJsonString(json);
    _hasTargetSnapshot = (_targetSnapshot.version > 0);
    
    // 检查配置兼容性
    if (_hasTargetSnapshot) {
        std::string myHash = computeConfigHash();
        if (myHash != _targetSnapshot.configHash) {
            CCLOG("[BattleShareManager] 警告：配置哈希不匹配");
            // 可以选择拒绝或继续
        }
    }
    
    return _hasTargetSnapshot;
}
```

### 16.3.2 建筑重建算法

```cpp
// BattleScene.cpp
void BattleScene::buildSnapshotLayout(const BaseSnapshot& snapshot) {
    auto* manager = BuildingManager::getInstance();
    float cellSize = _gridMap->getCellSize();
    
    // 创建基地（如果有锚点信息）
    if (snapshot.baseAnchor.x > 0) {
        createEnemyBase(
            static_cast<int>(snapshot.baseAnchor.x),
            static_cast<int>(snapshot.baseAnchor.y),
            snapshot.baseLevel
        );
    }
    
    // 创建所有建筑
    for (const auto& saved : snapshot.buildings) {
        Node* building = nullptr;
        int width = 3, height = 3;  // 默认尺寸
        
        if (saved.isDefence) {
            const auto* config = manager->getDefenceConfig(saved.configId);
            if (config) {
                building = manager->createDefenceBuilding(
                    saved.configId, saved.level);
                width = config->width;
                height = config->length;
            }
        } else {
            const auto* config = manager->getProductionConfig(saved.configId);
            if (config) {
                building = manager->createProductionBuilding(
                    saved.configId, saved.level);
                width = config->width;
                height = config->length;
            }
        }
        
        if (building) {
            _buildingLayer->addChild(building);
            
            // 计算位置
            float centerX = (saved.gridX + width * 0.5f) * cellSize;
            float centerY = (saved.gridY + height * 0.5f) * cellSize;
            building->setPosition(Vec2(centerX, centerY));
            
            // 缩放
            scaleBuildingToFit(building, width, height, cellSize);
            
            // 标记网格
            _gridMap->occupyCell(saved.gridX, saved.gridY, width, height, building);
            
            // 记录为敌方建筑
            _enemyBuildings.push_back(building);
            building->retain();
            _totalBuildingCount++;
        }
    }
}
```

---

## 16.4 分享目录管理

### 16.4.1 路径生成

```cpp
std::string BattleShareManager::getSharePath(const std::string& filename) {
    std::string shareDir = FileUtils::getInstance()->getWritablePath() + "share/";
    
    // 确保目录存在
    if (!FileUtils::getInstance()->isDirectoryExist(shareDir)) {
        FileUtils::getInstance()->createDirectory(shareDir);
    }
    
    return shareDir + filename;
}

// Windows 示例路径
// C:\Users\<用户名>\AppData\Local\VoidKings\share\

// Android 示例路径
// /data/data/com.yourcompany.voidkings/files/share/
```

### 16.4.2 文件检测 API

```cpp
bool BattleShareManager::hasIncomingSnapshot() const {
    std::string path = getSharePath("target_base_snapshot.json");
    return FileUtils::getInstance()->isFileExist(path);
}

bool BattleShareManager::hasIncomingReplay() const {
    std::string path = getSharePath("target_replay.json");
    return FileUtils::getInstance()->isFileExist(path);
}

bool BattleShareManager::hasExportedSnapshot() const {
    std::string path = getSharePath("my_base_snapshot.json");
    return FileUtils::getInstance()->isFileExist(path);
}
```

---

## 16.5 完整工作流程

### 16.5.1 玩家 A 导出基地

```cpp
void BaseScene::onExportBaseClicked() {
    bool success = BattleShareManager::getInstance()->exportPlayerBaseSnapshot();
    
    if (success) {
        showStatus("Base exported to share/my_base_snapshot.json");
    } else {
        showStatus("Export failed!");
    }
}
```

### 16.5.2 玩家 B 导入并进攻

```cpp
void BaseScene::onLoadTargetAndAttackClicked() {
    auto* manager = BattleShareManager::getInstance();
    
    if (!manager->loadIncomingSnapshot()) {
        showStatus("No target_base_snapshot.json found");
        return;
    }
    
    // 准备兵种
    std::map<int, int> units = UnitManager::getInstance()->getTrainedUnitsData();
    
    // 创建快照战斗场景
    auto scene = BattleScene::createSnapshotScene(
        manager->getTargetSnapshot(),
        units,
        true  // 允许默认兵种
    );
    
    if (scene) {
        Director::getInstance()->pushScene(scene);
    }
}
```

### 16.5.3 回放导出与分享

```cpp
void BaseScene::onExportLastReplayClicked() {
    auto* replayMgr = ReplayManager::getInstance();
    
    if (!replayMgr->hasLastReplay()) {
        showStatus("No replay to export");
        return;
    }
    
    std::string path = BattleShareManager::getInstance()
        ->getSharePath("last_replay.json");
    
    bool success = replayMgr->exportReplayTo(path, replayMgr->getLastReplay());
    
    if (success) {
        showStatus("Replay exported");
    }
}
```

### 16.5.4 玩家 A 观看回放

```cpp
void BaseScene::onPlayImportedReplayClicked() {
    std::string path = BattleShareManager::getInstance()
        ->getSharePath("target_replay.json");
    
    BattleReplay replay;
    if (!ReplayManager::getInstance()->importReplayFrom(path, replay)) {
        showStatus("No target_replay.json found");
        return;
    }
    
    // 创建回放场景
    auto scene = BattleScene::createReplayScene(replay);
    if (scene) {
        Director::getInstance()->pushScene(scene);
    }
}
```

---

## UI 面板实现

```cpp
void BaseScene::setupAsyncPanel() {
    // 创建遮罩
    _asyncOverlay = LayerColor::create(Color4B(0, 0, 0, 180));
    _asyncOverlay->setVisible(false);
    this->addChild(_asyncOverlay, 200);
    
    // 创建面板
    _asyncPanel = Node::create();
    auto panelBg = LayerColor::create(Color4B(40, 40, 40, 240), 400, 300);
    panelBg->setAnchorPoint(Vec2(0.5f, 0.5f));
    _asyncPanel->addChild(panelBg);
    
    // 标题
    auto title = createBaseLabel("Async Operations", 20);
    title->setPosition(Vec2(0, 120));
    _asyncPanel->addChild(title);
    
    // 目录提示
    std::string hint = "Share directory:\n" + 
        BattleShareManager::getInstance()->getSharePath("");
    auto hintLabel = createBaseLabel(hint, 10);
    hintLabel->setPosition(Vec2(0, 80));
    _asyncPanel->addChild(hintLabel);
    
    // 按钮
    float btnY = 30;
    float btnSpacing = -45;
    
    auto exportBtn = createButton("EXPORT MY BASE", [this]() {
        onExportBaseClicked();
    });
    exportBtn->setPosition(Vec2(0, btnY));
    _asyncPanel->addChild(exportBtn);
    
    auto loadBtn = createButton("LOAD TARGET & ATTACK", [this]() {
        onLoadTargetAndAttackClicked();
    });
    loadBtn->setPosition(Vec2(0, btnY + btnSpacing));
    _asyncPanel->addChild(loadBtn);
    
    // ... 更多按钮 ...
    
    _asyncPanel->setPosition(visibleSize.width / 2, visibleSize.height / 2);
    _asyncOverlay->addChild(_asyncPanel);
}
```

---

## 本章小结

1. **异步攻防** 通过文件交换实现离线 PvP
2. **BaseSnapshot** 保存完整基地布局
3. **配置哈希** 确保双方游戏版本一致
4. **share 目录** 作为文件交换点
5. **工作流程** 导出→交换→导入→进攻→回放

---

## 练习题

1. 添加网络上传功能：将快照上传到服务器
2. 实现排行榜：记录进攻成功率
3. 添加快照预览：导入前查看基地布局

---

**下一章**：[第17章 游戏设置系统](第17章-游戏设置系统.md)
