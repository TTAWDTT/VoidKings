# 第14章 存档系统完整实现

> **本章目标**：深入理解 VoidKings 的多槽位存档系统，掌握数据序列化、保存恢复流程。

---

## 14.1 SaveManager 架构设计

### 14.1.1 单例初始化

```cpp
// Classes/Save/SaveManager.h
class SaveManager {
public:
    static SaveManager* getInstance();
    
    // 初始化存储
    bool init();
    
    // 槽位操作
    bool saveSlot(int slot);
    bool loadSlot(int slot);
    bool deleteSlot(int slot);
    bool isSlotEmpty(int slot);
    std::string getSlotInfo(int slot);
    
    // 当前槽位
    int getCurrentSlot() const { return _currentSlot; }
    void setCurrentSlot(int slot) { _currentSlot = slot; }
    
    // 重置游戏状态
    void resetGameState();
    
private:
    SaveManager();
    ~SaveManager();
    
    static SaveManager* _instance;
    int _currentSlot = 1;
    bool _initialized = false;
    
    // 辅助方法
    std::string buildSlotKey(int slot) const;
    bool validateSlot(int slot) const;
};
```

### 14.1.2 SQLite 封装（local-storage）

Cocos2d-x 提供 `localStorageInit/Get/Set` 函数封装 SQLite：

```cpp
// Classes/Save/SaveManager.cpp
#include "storage/local-storage/LocalStorage.h"

bool SaveManager::init() {
    if (_initialized) return true;
    
    // 获取可写路径
    std::string dbPath = FileUtils::getInstance()->getWritablePath() + 
                         "voidkings_saves.db";
    
    // 初始化 local-storage
    localStorageInit(dbPath);
    
    _initialized = true;
    
    CCLOG("[SaveManager] 存档系统初始化: %s", dbPath.c_str());
    return true;
}

// 关闭时清理（通常在游戏退出时调用）
SaveManager::~SaveManager() {
    if (_initialized) {
        localStorageFree();
    }
}
```

### 14.1.3 槽位键设计

```cpp
// 槽位键格式
constexpr int MAX_SLOTS = 6;
constexpr const char* SLOT_KEY_PREFIX = "vk_save_slot_";

std::string SaveManager::buildSlotKey(int slot) const {
    return StringUtils::format("%s%d", SLOT_KEY_PREFIX, slot);
}

bool SaveManager::validateSlot(int slot) const {
    return slot >= 1 && slot <= MAX_SLOTS;
}
```

---

## 14.2 存档数据结构

### 14.2.1 JSON Schema 设计

```json
{
  "version": 1,
  "meta": {
    "timestamp": 1703750400,
    "summary": "Lv.3 | 5000G | 12 Buildings",
    "playTime": 3600
  },
  "core": {
    "coin": 5000,
    "diamond": 150,
    "baseLevel": 3,
    "barracksLevel": 2,
    "levelStars": [
      { "id": 1, "stars": 3 },
      { "id": 2, "stars": 2 },
      { "id": 3, "stars": 3 }
    ]
  },
  "units": {
    "trained": [
      { "id": 1001, "count": 5 },
      { "id": 1002, "count": 3 }
    ],
    "levels": [
      { "id": 1001, "level": 2 },
      { "id": 1002, "level": 1 }
    ]
  },
  "base": {
    "buildings": [
      {
        "configId": 1001,
        "gridX": 10,
        "gridY": 12,
        "level": 2,
        "isDefence": true
      }
    ]
  }
}
```

### 14.2.2 建筑序列化

```cpp
struct BaseSavedBuilding {
    int configId;
    int gridX;
    int gridY;
    int level;
    bool isDefence;
    
    rapidjson::Value toJson(rapidjson::Document::AllocatorType& alloc) const {
        rapidjson::Value obj(rapidjson::kObjectType);
        obj.AddMember("configId", configId, alloc);
        obj.AddMember("gridX", gridX, alloc);
        obj.AddMember("gridY", gridY, alloc);
        obj.AddMember("level", level, alloc);
        obj.AddMember("isDefence", isDefence, alloc);
        return obj;
    }
    
    static BaseSavedBuilding fromJson(const rapidjson::Value& obj) {
        BaseSavedBuilding b;
        b.configId = obj["configId"].GetInt();
        b.gridX = obj["gridX"].GetInt();
        b.gridY = obj["gridY"].GetInt();
        b.level = obj.HasMember("level") ? obj["level"].GetInt() : 0;
        b.isDefence = obj.HasMember("isDefence") ? obj["isDefence"].GetBool() : true;
        return b;
    }
};
```

### 14.2.3 兵种数据序列化

```cpp
rapidjson::Value serializeUnits(rapidjson::Document::AllocatorType& alloc) {
    rapidjson::Value units(rapidjson::kObjectType);
    
    // 训练队列
    rapidjson::Value trained(rapidjson::kArrayType);
    for (const auto& pair : UnitManager::getInstance()->getTrainedUnitsData()) {
        rapidjson::Value item(rapidjson::kObjectType);
        item.AddMember("id", pair.first, alloc);
        item.AddMember("count", pair.second, alloc);
        trained.PushBack(item, alloc);
    }
    units.AddMember("trained", trained, alloc);
    
    // 等级数据
    rapidjson::Value levels(rapidjson::kArrayType);
    for (const auto& pair : UnitManager::getInstance()->getUnitLevelsData()) {
        rapidjson::Value item(rapidjson::kObjectType);
        item.AddMember("id", pair.first, alloc);
        item.AddMember("level", pair.second, alloc);
        levels.PushBack(item, alloc);
    }
    units.AddMember("levels", levels, alloc);
    
    return units;
}
```

---

## 14.3 保存流程

### 14.3.1 saveSlot(int slot) 源码

```cpp
bool SaveManager::saveSlot(int slot) {
    if (!validateSlot(slot)) {
        CCLOG("[SaveManager] 无效槽位: %d", slot);
        return false;
    }
    
    // 1. 创建 JSON 文档
    rapidjson::Document doc;
    doc.SetObject();
    auto& alloc = doc.GetAllocator();
    
    // 2. 版本号
    doc.AddMember("version", 1, alloc);
    
    // 3. 元数据
    rapidjson::Value meta(rapidjson::kObjectType);
    auto now = std::chrono::system_clock::now();
    auto timestamp = std::chrono::duration_cast<std::chrono::seconds>(
        now.time_since_epoch()).count();
    meta.AddMember("timestamp", static_cast<int64_t>(timestamp), alloc);
    
    std::string summary = StringUtils::format("Lv.%d | %dG", 
        Core::getInstance()->getBaseLevel(),
        Core::getInstance()->getResource(ResourceType::COIN));
    rapidjson::Value summaryVal;
    summaryVal.SetString(summary.c_str(), alloc);
    meta.AddMember("summary", summaryVal, alloc);
    
    doc.AddMember("meta", meta, alloc);
    
    // 4. 核心数据
    rapidjson::Value core(rapidjson::kObjectType);
    core.AddMember("coin", 
        Core::getInstance()->getResource(ResourceType::COIN), alloc);
    core.AddMember("diamond", 
        Core::getInstance()->getResource(ResourceType::DIAMOND), alloc);
    core.AddMember("baseLevel", 
        Core::getInstance()->getBaseLevel(), alloc);
    
    // 关卡星级
    rapidjson::Value levelStars(rapidjson::kArrayType);
    for (const auto& pair : Core::getInstance()->getLevelStarsData()) {
        rapidjson::Value item(rapidjson::kObjectType);
        item.AddMember("id", pair.first, alloc);
        item.AddMember("stars", pair.second, alloc);
        levelStars.PushBack(item, alloc);
    }
    core.AddMember("levelStars", levelStars, alloc);
    
    doc.AddMember("core", core, alloc);
    
    // 5. 兵种数据
    doc.AddMember("units", serializeUnits(alloc), alloc);
    
    // 6. 建筑数据
    rapidjson::Value base(rapidjson::kObjectType);
    rapidjson::Value buildings(rapidjson::kArrayType);
    for (const auto& b : BaseScene::getSavedBuildings()) {
        buildings.PushBack(b.toJson(alloc), alloc);
    }
    base.AddMember("buildings", buildings, alloc);
    doc.AddMember("base", base, alloc);
    
    // 7. 序列化为字符串
    rapidjson::StringBuffer buffer;
    rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
    doc.Accept(writer);
    
    // 8. 写入存储
    std::string key = buildSlotKey(slot);
    localStorageSetItem(key, buffer.GetString());
    
    CCLOG("[SaveManager] 保存成功: 槽位 %d", slot);
    return true;
}
```

---

## 14.4 加载流程

### 14.4.1 loadSlot(int slot) 源码

```cpp
bool SaveManager::loadSlot(int slot) {
    if (!validateSlot(slot)) {
        CCLOG("[SaveManager] 无效槽位: %d", slot);
        return false;
    }
    
    // 1. 读取存储
    std::string key = buildSlotKey(slot);
    std::string jsonData;
    localStorageGetItem(key, &jsonData);
    
    if (jsonData.empty()) {
        CCLOG("[SaveManager] 槽位为空: %d", slot);
        return false;
    }
    
    // 2. 解析 JSON
    rapidjson::Document doc;
    doc.Parse(jsonData.c_str());
    
    if (doc.HasParseError()) {
        CCLOG("[SaveManager] JSON 解析错误");
        return false;
    }
    
    // 3. 版本检查
    int version = doc.HasMember("version") ? doc["version"].GetInt() : 0;
    if (version > 1) {
        CCLOG("[SaveManager] 存档版本过高: %d", version);
        return false;
    }
    
    // 4. 重置当前状态
    resetGameState();
    
    // 5. 恢复核心数据
    if (doc.HasMember("core")) {
        const auto& core = doc["core"];
        
        Core::getInstance()->setResource(ResourceType::COIN, 
            core["coin"].GetInt());
        Core::getInstance()->setResource(ResourceType::DIAMOND, 
            core["diamond"].GetInt());
        Core::getInstance()->setBaseLevel(
            core["baseLevel"].GetInt());
        
        // 恢复星级
        if (core.HasMember("levelStars") && core["levelStars"].IsArray()) {
            std::vector<std::pair<int, int>> starsData;
            for (const auto& item : core["levelStars"].GetArray()) {
                starsData.emplace_back(
                    item["id"].GetInt(), 
                    item["stars"].GetInt());
            }
            Core::getInstance()->setLevelStarsData(starsData);
        }
    }
    
    // 6. 恢复兵种数据
    if (doc.HasMember("units")) {
        const auto& units = doc["units"];
        
        std::map<int, int> trained;
        if (units.HasMember("trained") && units["trained"].IsArray()) {
            for (const auto& item : units["trained"].GetArray()) {
                trained[item["id"].GetInt()] = item["count"].GetInt();
            }
        }
        
        std::map<int, int> levels;
        if (units.HasMember("levels") && units["levels"].IsArray()) {
            for (const auto& item : units["levels"].GetArray()) {
                levels[item["id"].GetInt()] = item["level"].GetInt();
            }
        }
        
        UnitManager::getInstance()->restoreState(trained, levels);
    }
    
    // 7. 恢复建筑数据
    if (doc.HasMember("base") && doc["base"].HasMember("buildings")) {
        std::vector<BaseSavedBuilding> buildings;
        for (const auto& item : doc["base"]["buildings"].GetArray()) {
            buildings.push_back(BaseSavedBuilding::fromJson(item));
        }
        BaseScene::setSavedBuildings(buildings);
    }
    
    _currentSlot = slot;
    CCLOG("[SaveManager] 加载成功: 槽位 %d", slot);
    return true;
}
```

---

## 14.5 槽位管理

### 14.5.1 槽位信息查询

```cpp
std::string SaveManager::getSlotInfo(int slot) {
    if (!validateSlot(slot)) return "Invalid Slot";
    
    std::string key = buildSlotKey(slot);
    std::string jsonData;
    localStorageGetItem(key, &jsonData);
    
    if (jsonData.empty()) {
        return "Empty Slot";
    }
    
    rapidjson::Document doc;
    doc.Parse(jsonData.c_str());
    
    if (doc.HasParseError()) {
        return "Corrupted Save";
    }
    
    // 提取摘要
    if (doc.HasMember("meta") && doc["meta"].HasMember("summary")) {
        return doc["meta"]["summary"].GetString();
    }
    
    return "Unknown Save";
}

bool SaveManager::isSlotEmpty(int slot) {
    if (!validateSlot(slot)) return true;
    
    std::string key = buildSlotKey(slot);
    std::string data;
    localStorageGetItem(key, &data);
    
    return data.empty();
}
```

### 14.5.2 槽位删除

```cpp
bool SaveManager::deleteSlot(int slot) {
    if (!validateSlot(slot)) return false;
    
    std::string key = buildSlotKey(slot);
    localStorageRemoveItem(key);
    
    CCLOG("[SaveManager] 删除槽位: %d", slot);
    return true;
}
```

### 14.5.3 活动槽位切换

```cpp
void SaveManager::resetGameState() {
    // 重置核心数据
    Core::getInstance()->resetToDefault();
    
    // 重置兵种数据
    UnitManager::getInstance()->resetState();
    
    // 清空建筑列表
    BaseScene::clearSavedBuildings();
    
    CCLOG("[SaveManager] 游戏状态已重置");
}

// 切换槽位时的完整流程
void MainMenuScene::onSlotSelected(int slot) {
    // 1. 保存当前槽位
    if (SaveManager::getInstance()->getCurrentSlot() > 0) {
        SaveManager::getInstance()->saveSlot(
            SaveManager::getInstance()->getCurrentSlot());
    }
    
    // 2. 加载新槽位
    if (SaveManager::getInstance()->isSlotEmpty(slot)) {
        // 空槽位：创建新游戏
        SaveManager::getInstance()->resetGameState();
        SaveManager::getInstance()->saveSlot(slot);
    } else {
        // 有存档：加载
        SaveManager::getInstance()->loadSlot(slot);
    }
    
    // 3. 设置当前槽位
    SaveManager::getInstance()->setCurrentSlot(slot);
    
    // 4. 进入游戏
    Director::getInstance()->replaceScene(BaseScene::createScene());
}
```

---

## 存档路径

```cpp
// 获取存档路径
std::string getWritablePath() {
    return FileUtils::getInstance()->getWritablePath();
}

// Windows 示例
// C:\Users\<用户名>\AppData\Local\VoidKings\voidkings_saves.db

// Android 示例
// /data/data/com.yourcompany.voidkings/files/voidkings_saves.db

// 或者（外部存储，需要权限）
// /storage/emulated/0/Android/data/com.yourcompany.voidkings/files/
```

---

## 本章小结

1. **SaveManager 单例** 管理所有存档操作
2. **local-storage** 底层使用 SQLite，键值对存储
3. **JSON 序列化** 便于调试和版本兼容
4. **6 个槽位** 支持多存档
5. **resetGameState()** 确保切换槽位时数据干净

---

## 练习题

1. 添加存档备份功能：导出存档到文件
2. 实现存档云同步：上传到服务器
3. 添加存档加密：防止玩家修改

---

**下一章**：[第15章 战斗回放系统](第15章-战斗回放系统.md)
