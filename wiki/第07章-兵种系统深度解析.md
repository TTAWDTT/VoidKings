# 第7章 兵种系统深度解析

> **本章目标**：深入理解 VoidKings 的士兵系统，包括类设计、AI 行为、移动攻击逻辑等核心实现。

---

## 7.1 Soldier 士兵类设计哲学

### 7.1.1 为什么继承 Node 而非 Sprite

```cpp
// 错误做法：直接继承 Sprite
class Soldier : public Sprite { ... }  // ❌

// 正确做法：继承 Node
class Soldier : public Node { ... }    // ✓
```

**原因**：

1. **复合结构**：士兵不只是一张图片
   ```cpp
   // Soldier 包含多个子节点
   Soldier
   ├── _bodySprite (身体贴图/动画)
   ├── _shadowSprite (阴影)
   ├── _healthBar (血条)
   └── _effectNode (特效层)
   ```

2. **灵活性**：可以随时更换主精灵而不影响位置
3. **层次管理**：各部分可以有独立的 zOrder

### 7.1.2 配置模板指针（享元模式）

```cpp
// Classes/Soldier/Soldier.h
class Soldier : public Node {
private:
    // 配置模板——一个指针引用（享元模式）
    // 所有同类型士兵共享同一份配置，节省内存
    const UnitConfig* _config;
    
    // 运行时数据——每个实例独有
    int _level;              // 当前等级
    float _currentHP;        // 当前血量
    float _attackTimer;      // 攻击冷却
    float _targetRefreshTimer;  // 目标刷新计时
    Node* _currentTarget;    // 当前攻击目标
};
```

**内存对比**：
- 100 个枪兵：
  - 不用享元：100 × sizeof(UnitConfig) ≈ 100 × 200 = 20KB
  - 使用享元：1 × sizeof(UnitConfig) + 100 × sizeof(指针) = 200 + 800 = 1KB

### 7.1.3 运行时状态管理

```cpp
// 士兵状态（简化版状态机）
enum class SoldierState {
    IDLE,       // 待命
    MOVING,     // 移动中
    ATTACKING,  // 攻击中
    DEAD        // 已死亡
};

class Soldier : public Node {
private:
    SoldierState _state = SoldierState::IDLE;
    
public:
    bool isDead() const { return _currentHP <= 0; }
    bool isAttacking() const { return _state == SoldierState::ATTACKING; }
};
```

---

## 7.2 士兵初始化流程

### 7.2.1 配置加载与验证

```cpp
// Classes/Soldier/Soldier.cpp
bool Soldier::init(const UnitConfig* config, int level) {
    if (!Node::init()) return false;
    
    // 验证配置
    if (!config) {
        CCLOG("[Soldier] 配置为空");
        return false;
    }
    
    _config = config;
    _level = std::min(level, config->MAXLEVEL);
    _currentHP = getCurrentMaxHP();
    _attackTimer = 0.0f;
    _targetRefreshTimer = 0.0f;
    _currentTarget = nullptr;
    _state = SoldierState::IDLE;
    
    // ... 继续初始化
    return true;
}
```

### 7.2.2 精灵创建与占位图

```cpp
bool Soldier::init(const UnitConfig* config, int level) {
    // ... 前面的配置验证 ...
    
    // 创建身体精灵
    std::string spritePath = config->spriteFrameName;
    _bodySprite = Sprite::create(spritePath);
    
    if (!_bodySprite) {
        // 使用占位图
        _bodySprite = Sprite::create("unit/placeholder.png");
        CCLOG("[Soldier] 使用占位图: %s", spritePath.c_str());
    }
    
    if (_bodySprite) {
        _bodySprite->setName("bodySprite");
        this->addChild(_bodySprite, 0);
    }
    
    // 创建阴影
    _shadowSprite = Sprite::create("unit/shadow.png");
    if (_shadowSprite) {
        _shadowSprite->setPosition(Vec2(0, -10));
        _shadowSprite->setOpacity(100);
        this->addChild(_shadowSprite, -1);
    }
    
    return true;
}
```

### 7.2.3 血条初始化

```cpp
void Soldier::createHealthBar() {
    _healthBarNode = Node::create();
    
    // 背景条
    auto bg = Sprite::create("res/health_bar_bg.png");
    bg->setScale(0.5f);
    _healthBarNode->addChild(bg, 0);
    
    // 前景条
    _healthBarFg = Sprite::create("res/health_bar.png");
    _healthBarFg->setScale(0.5f);
    _healthBarFg->setAnchorPoint(Vec2(0, 0.5f));
    _healthBarFg->setPositionX(-bg->getContentSize().width * 0.25f);
    _healthBarNode->addChild(_healthBarFg, 1);
    
    // 放置在头顶
    float yOffset = _bodySprite ? 
        _bodySprite->getContentSize().height * 0.5f + 5 : 20;
    _healthBarNode->setPosition(Vec2(0, yOffset));
    
    this->addChild(_healthBarNode, 100);
}
```

### 7.2.4 Update 循环启动

```cpp
bool Soldier::init(const UnitConfig* config, int level) {
    // ... 前面的初始化 ...
    
    // 创建血条
    createHealthBar();
    
    // 启动待机动画
    playAnimation(AnimationType::IDLE);
    
    // 启动更新循环
    this->scheduleUpdate();
    
    return true;
}
```

---

## 7.3 士兵 AI 行为实现

### 7.3.1 目标刷新策略（0.25秒间隔）

频繁寻敌会消耗性能，因此设置刷新间隔：

```cpp
void Soldier::update(float dt) {
    if (isDead()) return;
    
    // 1. 累积目标刷新计时器
    _targetRefreshTimer += dt;
    
    // 2. 每 0.25 秒重新评估目标
    if (_targetRefreshTimer >= 0.25f) {
        _targetRefreshTimer = 0.0f;
        refreshTarget();
    }
    
    // 3. 执行行为
    if (_currentTarget) {
        float dist = getDistanceToTarget(_currentTarget);
        if (dist <= getAttackRange()) {
            attackTarget(dt);
        } else {
            moveToTarget(dt);
        }
    } else {
        // 无目标时待命
        if (_state != SoldierState::IDLE) {
            _state = SoldierState::IDLE;
            playAnimation(AnimationType::IDLE);
        }
    }
}
```

### 7.3.2 目标优先级评分算法

```cpp
void Soldier::refreshTarget() {
    if (!s_enemyBuildings || s_enemyBuildings->empty()) {
        _currentTarget = nullptr;
        return;
    }
    
    Node* bestTarget = nullptr;
    float bestScore = FLT_MAX;
    float attackRange = getAttackRange();
    
    // 评分函数：距离 - 攻击范围，越小越好
    auto calcScore = [&](Node* building, float& outDist) -> float {
        outDist = getDistanceToTarget(building);
        float score = outDist - attackRange;
        return std::max(0.0f, score);
    };
    
    // 遍历所有建筑
    for (Node* building : *s_enemyBuildings) {
        if (!building || !building->getParent()) continue;
        
        // 检查建筑是否已摧毁
        if (isBuildingDestroyed(building)) continue;
        
        // AI 类型过滤
        if (!shouldTargetBuilding(building)) continue;
        
        float dist;
        float score = calcScore(building, dist);
        
        // 优先攻击已锁定的目标（减少切换）
        if (building == _currentTarget) {
            score -= 10.0f;
        }
        
        if (score < bestScore) {
            bestScore = score;
            bestTarget = building;
        }
    }
    
    _currentTarget = bestTarget;
}
```

### 7.3.3 目标切换防抖动

为避免士兵在两个目标间频繁切换：

```cpp
void Soldier::refreshTarget() {
    // ... 计算最佳目标 ...
    
    // 防抖动：只有新目标明显更优时才切换
    if (_currentTarget && bestTarget != _currentTarget) {
        float currentScore = getScoreForTarget(_currentTarget);
        float newScore = getScoreForTarget(bestTarget);
        
        // 新目标需要比当前目标好 20% 以上才切换
        if (newScore >= currentScore * 0.8f) {
            // 保持当前目标
            return;
        }
    }
    
    _currentTarget = bestTarget;
}
```

### 7.3.4 AI 类型（资源/防御/任意）

不同兵种有不同的目标偏好：

```cpp
// Classes/Soldier/UnitData.h
enum class AITargetType {
    ANY,        // 攻击任意建筑
    DEFENCE,    // 优先攻击防御建筑
    RESOURCE,   // 优先攻击资源建筑
    BASE        // 直接攻击基地
};

// Soldier.cpp
bool Soldier::shouldTargetBuilding(Node* building) const {
    switch (_config->aiType) {
        case AITargetType::DEFENCE:
            // 优先攻击防御塔
            return dynamic_cast<DefenceBuilding*>(building) != nullptr;
            
        case AITargetType::RESOURCE:
            // 优先攻击生产/存储建筑
            return dynamic_cast<ProductionBuilding*>(building) != nullptr ||
                   dynamic_cast<StorageBuilding*>(building) != nullptr;
            
        case AITargetType::BASE:
            // 只攻击主基地
            return isMainBase(building);
            
        case AITargetType::ANY:
        default:
            return true;
    }
}
```

---

## 7.4 士兵移动逻辑

### 7.4.1 moveToTarget(float dt) 源码

```cpp
void Soldier::moveToTarget(float dt) {
    if (!_currentTarget) return;
    
    // 更新状态
    if (_state != SoldierState::MOVING) {
        _state = SoldierState::MOVING;
        playAnimation(AnimationType::WALK);
    }
    
    // 计算方向
    Vec2 myPos = this->getPosition();
    Vec2 targetPos = getTargetCenter(_currentTarget);
    Vec2 direction = targetPos - myPos;
    
    float distance = direction.length();
    if (distance < 1.0f) return;  // 防止除零
    
    direction.normalize();
    
    // 计算移动步长
    float speed = getCurrentSpeed();
    float step = speed * dt;
    
    // 限制步长不超过剩余距离
    step = std::min(step, distance);
    
    // 应用移动
    Vec2 newPos = myPos + direction * step;
    this->setPosition(newPos);
    
    // 更新朝向
    updateSpriteDirection(direction);
}
```

### 7.4.2 速度与步长计算

```cpp
float Soldier::getCurrentSpeed() const {
    if (!_config) return 50.0f;
    
    // 从配置获取当前等级的速度
    if (_level < static_cast<int>(_config->SPEED.size())) {
        return _config->SPEED[_level];
    }
    
    // 回退到最高等级速度
    if (!_config->SPEED.empty()) {
        return _config->SPEED.back();
    }
    
    return 50.0f;  // 默认速度
}
```

### 7.4.3 最小移动步长阈值

避免微小移动导致的抖动：

```cpp
void Soldier::moveToTarget(float dt) {
    // ...
    
    float step = speed * dt;
    
    // 最小步长阈值
    constexpr float MIN_STEP = 0.5f;
    if (step < MIN_STEP && distance > MIN_STEP) {
        return;  // 步长太小，跳过本帧
    }
    
    // ...
}
```

### 7.4.4 方向计算与精灵翻转

```cpp
void Soldier::updateSpriteDirection(const Vec2& direction) {
    if (!_bodySprite) return;
    
    // 根据 X 方向翻转精灵
    if (direction.x < -0.1f) {
        // 向左：翻转
        _bodySprite->setScaleX(-std::abs(_bodySprite->getScaleX()));
    } else if (direction.x > 0.1f) {
        // 向右：正常
        _bodySprite->setScaleX(std::abs(_bodySprite->getScaleX()));
    }
    // X 接近 0 时保持当前方向
}
```

---

## 7.5 士兵攻击逻辑

### 7.5.1 攻击间隔控制

```cpp
void Soldier::attackTarget(float dt) {
    if (!_currentTarget) return;
    
    // 更新状态
    if (_state != SoldierState::ATTACKING) {
        _state = SoldierState::ATTACKING;
    }
    
    // 累积攻击计时器
    _attackTimer += dt;
    
    // 检查攻击间隔
    float attackSpeed = getCurrentAttackSpeed();
    if (_attackTimer >= attackSpeed) {
        _attackTimer = 0.0f;
        performAttack();
    }
}

float Soldier::getCurrentAttackSpeed() const {
    if (!_config) return 1.0f;
    
    if (_level < static_cast<int>(_config->ATK_SPEED.size())) {
        return _config->ATK_SPEED[_level];
    }
    
    return 1.0f;
}
```

### 7.5.2 近战/远程判定

```cpp
void Soldier::performAttack() {
    if (!_currentTarget) return;
    
    // 播放攻击动画
    playAnimation(AnimationType::ATTACK);
    
    float damage = getCurrentATK();
    
    if (_config->isRanged) {
        // 远程：发射子弹
        shootBullet(damage);
    } else {
        // 近战：直接造成伤害
        dealDamageToTarget(damage);
        AudioManager::playMeleeHit();
    }
}
```

### 7.5.3 不同建筑类型伤害处理

```cpp
void Soldier::dealDamageToTarget(float damage) {
    if (!_currentTarget) return;
    
    // 根据建筑类型调用不同方法
    if (auto* defence = dynamic_cast<DefenceBuilding*>(_currentTarget)) {
        defence->takeDamage(damage);
    } 
    else if (auto* production = dynamic_cast<ProductionBuilding*>(_currentTarget)) {
        production->takeDamage(damage);
    } 
    else if (auto* storage = dynamic_cast<StorageBuilding*>(_currentTarget)) {
        storage->takeDamage(damage);
    }
}
```

### 7.5.4 攻击动画与音效

```cpp
void Soldier::playAnimation(AnimationType type) {
    if (!_bodySprite) return;
    
    std::string animKey;
    int frameCount = 0;
    float delay = 0.1f;
    bool loop = true;
    
    switch (type) {
        case AnimationType::IDLE:
            animKey = _config->anim_idle;
            frameCount = _config->anim_idle_frames;
            delay = _config->anim_idle_delay;
            break;
            
        case AnimationType::WALK:
            animKey = _config->anim_walk;
            frameCount = _config->anim_walk_frames;
            delay = _config->anim_walk_delay;
            break;
            
        case AnimationType::ATTACK:
            animKey = _config->anim_attack;
            frameCount = _config->anim_attack_frames;
            delay = _config->anim_attack_delay;
            loop = false;  // 攻击动画不循环
            break;
            
        case AnimationType::DEATH:
            animKey = _config->anim_death;
            frameCount = _config->anim_death_frames;
            delay = _config->anim_death_delay;
            loop = false;
            break;
    }
    
    // 创建动画
    auto anim = AnimationUtils::buildAnimationFromFrames(
        _config->spriteBaseName, animKey, frameCount, delay, true);
    
    if (anim) {
        _bodySprite->stopAllActions();
        
        if (loop) {
            _bodySprite->runAction(
                RepeatForever::create(Animate::create(anim)));
        } else {
            _bodySprite->runAction(Animate::create(anim));
        }
    }
}
```

---

## 7.6 距离计算精细化

### 7.6.1 中心点距离 vs 边缘距离

简单的中心距离可能导致攻击判定不准确：

```cpp
// 简单距离（中心到中心）
float Soldier::getSimpleDistance(Node* target) const {
    return this->getPosition().distance(target->getPosition());
}

// 精确距离（考虑建筑大小）
float Soldier::getDistanceToTarget(Node* target) const {
    Vec2 myPos = this->getPosition();
    
    // 获取目标边界
    Rect targetRect = getTargetBoundingBox(target);
    
    // 计算点到矩形的距离
    return rectDistance(myPos, targetRect);
}
```

### 7.6.2 rectDistance() 矩形边缘距离算法

```cpp
float Soldier::rectDistance(const Vec2& point, const Rect& rect) const {
    // 计算点到矩形最近边缘的距离
    
    float dx = 0.0f;
    float dy = 0.0f;
    
    if (point.x < rect.getMinX()) {
        dx = rect.getMinX() - point.x;
    } else if (point.x > rect.getMaxX()) {
        dx = point.x - rect.getMaxX();
    }
    
    if (point.y < rect.getMinY()) {
        dy = rect.getMinY() - point.y;
    } else if (point.y > rect.getMaxY()) {
        dy = point.y - rect.getMaxY();
    }
    
    // 如果点在矩形内，距离为 0
    if (dx == 0.0f && dy == 0.0f) {
        return 0.0f;
    }
    
    return std::sqrt(dx * dx + dy * dy);
}
```

### 7.6.3 坐标空间转换

```cpp
Rect Soldier::getTargetBoundingBox(Node* target) const {
    if (!target) return Rect::ZERO;
    
    // 获取目标在世界坐标系中的边界框
    auto* parent = target->getParent();
    if (!parent) return Rect::ZERO;
    
    Rect localRect = target->getBoundingBox();
    Vec2 worldBL = parent->convertToWorldSpace(localRect.origin);
    Vec2 worldTR = parent->convertToWorldSpace(
        localRect.origin + Vec2(localRect.size.width, localRect.size.height));
    
    // 转换到自己的父节点坐标系
    auto* myParent = this->getParent();
    if (myParent) {
        Vec2 localBL = myParent->convertToNodeSpace(worldBL);
        Vec2 localTR = myParent->convertToNodeSpace(worldTR);
        return Rect(localBL.x, localBL.y, 
                    localTR.x - localBL.x, localTR.y - localBL.y);
    }
    
    return Rect(worldBL.x, worldBL.y, 
                worldTR.x - worldBL.x, worldTR.y - worldBL.y);
}
```

---

## 本章小结

1. **Soldier 继承 Node** 而非 Sprite，支持复合结构
2. **享元模式** 共享配置数据，节省内存
3. **目标刷新间隔** 避免每帧寻敌的性能开销
4. **防抖动机制** 减少目标频繁切换
5. **精确距离计算** 考虑建筑边界，提高攻击准确性

---

## 练习题

1. 添加飞行单位：忽略地面障碍，只能被对空塔攻击
2. 实现治疗兵：不攻击敌人，而是治疗友方
3. 给士兵添加死亡掉落金币功能

---

**下一章**：[第8章 UnitManager 兵种管理器](第08章-UnitManager兵种管理器.md)
